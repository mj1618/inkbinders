# Task: Engine Core — Game Loop, Renderer, Input, Entities, State Machine

## What to Build

Implement the foundational game engine systems that everything else depends on. After this task, we have a working fixed-timestep game loop, a Canvas 2D renderer with layering, a keyboard input system with buffering, a minimal entity system, and a generic state machine. These systems are wired together so that mounting a `GameCanvas` component can spin up a live engine instance.

This is pure engine code in `src/engine/` — no React dependencies. The bridge to React happens via `GameCanvas` component updates.

## Files to Create/Modify

### New files:

- `src/engine/core/GameLoop.ts` — Fixed-timestep game loop
- `src/engine/core/Renderer.ts` — Canvas 2D renderer with layer system
- `src/engine/core/Camera.ts` — Camera with position and viewport transform
- `src/engine/core/Engine.ts` — Top-level engine orchestrator (owns loop, renderer, input, entities)
- `src/engine/input/InputManager.ts` — Keyboard input with action mapping and buffering
- `src/engine/entities/Entity.ts` — Base entity with position, velocity, size, state
- `src/engine/entities/EntityManager.ts` — Entity registry (add/remove/iterate)
- `src/engine/states/StateMachine.ts` — Generic finite state machine
- `src/engine/physics/AABB.ts` — AABB collision detection utilities

### Modified files:

- `src/engine/core/index.ts` — Re-export GameLoop, Renderer, Camera, Engine
- `src/engine/input/index.ts` — Re-export InputManager
- `src/engine/entities/index.ts` — Re-export Entity, EntityManager
- `src/engine/states/index.ts` — Re-export StateMachine
- `src/engine/physics/index.ts` — Re-export AABB
- `src/engine/index.ts` — Re-export all engine modules
- `src/lib/constants.ts` — Add engine-related constants (gravity, input buffer size, etc.)
- `src/lib/types.ts` — Add engine-related types (GameState, InputAction, RenderLayer, etc.)

## Detailed Specifications

### GameLoop (`src/engine/core/GameLoop.ts`)

Fixed-timestep loop with interpolated rendering. This is the heartbeat of the engine.

```typescript
interface GameLoopCallbacks {
  update: (dt: number) => void;          // Called at fixed timestep
  render: (interpolation: number) => void; // Called every frame with interpolation factor
}
```

- Use `requestAnimationFrame` for the render loop
- Fixed timestep: `FIXED_TIMESTEP` from constants (1/60 = ~16.67ms)
- Accumulator pattern: accumulate real delta time, drain in fixed-step increments
- Cap maximum accumulated time to prevent spiral of death (e.g., max 0.25s)
- Track and expose performance metrics:
  - `fps`: frames per second (smoothed rolling average)
  - `frameTime`: time of last frame in ms
  - `updateCount`: number of physics updates this frame
- Methods: `start()`, `stop()`, `isRunning()`
- The loop should be pausable and resumable

### Renderer (`src/engine/core/Renderer.ts`)

Canvas 2D renderer with a layer system for draw ordering.

```typescript
enum RenderLayer {
  Background = 0,
  World = 1,
  Entities = 2,
  FX = 3,
  Debug = 4,
}
```

- Holds a reference to the `CanvasRenderingContext2D`
- Methods for drawing primitives (these are building blocks — real sprites come later):
  - `fillRect(x, y, w, h, color)` — filled rectangle
  - `strokeRect(x, y, w, h, color, lineWidth?)` — outlined rectangle
  - `drawLine(x1, y1, x2, y2, color, lineWidth?)` — line segment
  - `drawCircle(x, y, radius, color, fill?)` — circle
  - `drawText(text, x, y, color, fontSize?, font?)` — text rendering
- `clear()` — clear the entire canvas
- `applyCamera(camera: Camera)` — translate/scale the context based on camera position
- `resetCamera()` — restore the context to screen space (for HUD/debug)
- All draw calls should respect the current camera transform when applied
- Layer system: render callbacks are registered per-layer, executed in order during the render pass

### Camera (`src/engine/core/Camera.ts`)

Camera represents the viewport into the game world.

- Properties: `position: Vec2` (center of viewport), `zoom: number` (default 1)
- `worldToScreen(worldPos: Vec2): Vec2` — convert world coordinates to screen pixels
- `screenToWorld(screenPos: Vec2): Vec2` — convert screen pixels to world coordinates
- `getViewportBounds(): Rect` — get the visible world-space rectangle
- Uses `CANVAS_WIDTH` and `CANVAS_HEIGHT` for viewport dimensions

### Engine (`src/engine/core/Engine.ts`)

Top-level orchestrator that owns and wires together all subsystems.

```typescript
interface EngineConfig {
  ctx: CanvasRenderingContext2D;
  width?: number;   // defaults to CANVAS_WIDTH
  height?: number;  // defaults to CANVAS_HEIGHT
}
```

- Creates and owns: `GameLoop`, `Renderer`, `InputManager`, `EntityManager`, `Camera`
- `start()` — starts the game loop
- `stop()` — stops the game loop
- `getLoop()`, `getRenderer()`, `getInput()`, `getEntities()`, `getCamera()` — accessors
- On each fixed update: runs `InputManager.update()`, then iterates all entities and calls their `update(dt)` method
- On each render: clears the canvas, applies camera, iterates all entities and calls their `render(renderer, interpolation)` method, then renders debug layer
- Exposes a way to register custom update and render callbacks (so test pages can inject behavior)

### InputManager (`src/engine/input/InputManager.ts`)

Keyboard input system with action mapping and input buffering.

```typescript
enum InputAction {
  Left = 'left',
  Right = 'right',
  Up = 'up',
  Down = 'down',
  Jump = 'jump',
  Dash = 'dash',
  Attack = 'attack',
  Crouch = 'crouch',
}
```

Default key bindings:
- ArrowLeft / a → Left
- ArrowRight / d → Right
- ArrowUp / w → Up
- ArrowDown / s → Down
- Space / z → Jump
- Shift / x → Dash
- j / Enter → Attack (NOT 'c' — too close to browser shortcuts)
- ArrowDown / s → Crouch (same as Down — context-dependent)

Input state per action:
- `isPressed(action)` — true only on the frame the key went down
- `isHeld(action)` — true while the key is held
- `isReleased(action)` — true only on the frame the key went up

Input buffer:
- Store recent `InputAction` events with timestamps
- `INPUT_BUFFER_SIZE` constant (default 10 frames = ~167ms at 60Hz)
- `hasBufferedInput(action, withinFrames)` — check if an action was pressed within N frames ago
- `consumeBufferedInput(action, withinFrames)` — same as above but removes it from the buffer (used for jump buffering — once consumed, it shouldn't trigger again)

Per-frame snapshot:
- `update()` called once per fixed timestep
- Transitions "just pressed" → "held", "just released" → "not pressed"
- This ensures physics sees consistent input during a single tick

Keyboard event handling:
- Listen on `window` for `keydown`/`keyup`
- Prevent default on game keys to avoid scrolling
- Handle focus loss gracefully (release all keys on blur)
- `attach()` and `detach()` methods for lifecycle management

### Entity (`src/engine/entities/Entity.ts`)

Base entity class that all game objects derive from.

```typescript
interface EntityConfig {
  position?: Vec2;
  size?: Vec2;
  color?: string;   // For placeholder rendering
}
```

Properties:
- `id: string` — unique identifier (use a simple counter or crypto.randomUUID)
- `position: Vec2` — world position (top-left corner)
- `velocity: Vec2` — pixels per second
- `size: Vec2` — width/height for AABB
- `color: string` — placeholder rendering color
- `active: boolean` — whether this entity participates in updates
- `prevPosition: Vec2` — position at the start of the frame (for interpolation)

Methods:
- `update(dt: number): void` — override in subclasses; base implementation applies velocity to position
- `render(renderer: Renderer, interpolation: number): void` — override in subclasses; base implementation draws a colored rectangle using interpolated position
- `getBounds(): Rect` — returns AABB from position + size
- `getInterpolatedPosition(interpolation: number): Vec2` — lerp between prevPosition and position

### EntityManager (`src/engine/entities/EntityManager.ts`)

Registry for all entities in the current scene.

- `add(entity: Entity): void`
- `remove(id: string): void`
- `get(id: string): Entity | undefined`
- `getAll(): Entity[]`
- `clear(): void`
- `update(dt: number): void` — calls `update` on all active entities
- `render(renderer: Renderer, interpolation: number): void` — calls `render` on all active entities

### StateMachine (`src/engine/states/StateMachine.ts`)

Generic finite state machine, usable for player character, enemies, or any stateful entity.

```typescript
interface State<C> {
  name: string;
  enter?: (context: C) => void;
  update?: (context: C, dt: number) => void;
  exit?: (context: C) => void;
}
```

- Generic over a context type `C` (will be the player entity for player states)
- `addState(state: State<C>): void`
- `setState(name: string): void` — calls `exit` on current state, then `enter` on new state
- `update(dt: number): void` — calls `update` on current state
- `getCurrentState(): string`
- `getPreviousState(): string | null`
- Tracks time spent in current state (useful for animations, timeouts)
- No-op if `setState` is called with the current state name (don't re-enter)

### AABB Collision (`src/engine/physics/AABB.ts`)

Utility functions for axis-aligned bounding box collision.

- `aabbOverlap(a: Rect, b: Rect): boolean` — do two AABBs overlap?
- `aabbContains(outer: Rect, point: Vec2): boolean` — is a point inside an AABB?
- `aabbIntersection(a: Rect, b: Rect): Rect | null` — return the overlap rectangle, or null
- `resolveAABB(moving: Rect, velocity: Vec2, static: Rect): { position: Vec2, normal: Vec2 }` — given a moving AABB and a static AABB, return the resolved position and the collision normal. Use simple projection (push out along the axis of minimum penetration).

### Constants to Add (`src/lib/constants.ts`)

```typescript
// Input
export const INPUT_BUFFER_SIZE = 10;  // frames

// Physics defaults (will be overridden by test page sliders)
export const DEFAULT_GRAVITY = 980;    // pixels/sec²
export const MAX_FALL_SPEED = 600;     // pixels/sec

// Debug
export const DEBUG_FONT = '12px monospace';
export const DEBUG_LINE_HEIGHT = 16;
```

### Types to Add (`src/lib/types.ts`)

```typescript
export type RenderLayer = 'background' | 'world' | 'entities' | 'fx' | 'debug';

export interface PerformanceMetrics {
  fps: number;
  frameTime: number;
  updateCount: number;
}
```

## Verification

After this task is complete, the developer should be able to:

1. **Import and instantiate the engine in any test page:**
   ```typescript
   import { Engine } from '@/engine/core/Engine';
   // In a GameCanvas onMount callback:
   const engine = new Engine({ ctx });
   engine.start();
   ```

2. **See a working game loop** — `requestAnimationFrame` running at ~60fps with fixed-timestep updates

3. **Create and render entities:**
   ```typescript
   const entity = new Entity({ position: { x: 100, y: 100 }, size: { x: 32, y: 48 }, color: '#22d3ee' });
   engine.getEntities().add(entity);
   // Entity renders as a colored rectangle on the canvas
   ```

4. **Read input:**
   ```typescript
   const input = engine.getInput();
   if (input.isHeld(InputAction.Right)) { /* move right */ }
   if (input.isPressed(InputAction.Jump)) { /* jump */ }
   ```

5. **Use the state machine:**
   ```typescript
   const sm = new StateMachine<Player>();
   sm.addState({ name: 'idle', enter: (p) => { ... }, update: (p, dt) => { ... } });
   sm.addState({ name: 'running', enter: (p) => { ... }, update: (p, dt) => { ... } });
   sm.setState('idle');
   ```

6. **`npx tsc --noEmit` passes** with zero errors

7. **`npm run build` succeeds**

To do a quick visual smoke test, temporarily modify any test page stub (e.g., ground-movement) to mount the engine and add a movable entity. But do NOT commit that change — the ground-movement test page implementation is the next task.

## Design Decisions (Pre-settled)

1. **Class-based entities** — entities are classes with `update`/`render` methods. This is simpler than a full ECS for our scope, and subclassing works well for Player, Enemy, etc.
2. **Enum-style InputAction** — use string literal union, not numeric enum, for readability in debug output.
3. **Generic StateMachine** — parameterized by context type so it can be reused for player, enemies, bosses, UI, etc.
4. **Simple AABB collision** — no swept collision or continuous detection yet. Minimum-penetration resolution is good enough for the movement prototype. We can upgrade later if tunneling becomes an issue.
5. **No sprite system yet** — entities render as colored rectangles. Sprite loading/animation is a separate concern that comes after movement feels right.
6. **Camera defaults to centered** — position (0,0) means the world origin is at the center of the canvas. This is standard for 2D games.
7. **Renderer uses immediate-mode drawing** — no retained scene graph. Each frame, everything is redrawn. This is simple and sufficient for our scale.

---

## Completion Summary

### Files Created (9):
- `src/engine/core/GameLoop.ts` — Fixed-timestep game loop with accumulator pattern, performance metrics (FPS, frame time, update count), start/stop/pause support
- `src/engine/core/Renderer.ts` — Canvas 2D renderer with layer system (background → world → entities → fx → debug), camera transform support, drawing primitives (fillRect, strokeRect, drawLine, drawCircle, drawText)
- `src/engine/core/Camera.ts` — Camera with position/zoom, worldToScreen/screenToWorld coordinate conversion, viewport bounds calculation
- `src/engine/core/Engine.ts` — Top-level orchestrator wiring GameLoop, Renderer, InputManager, EntityManager, Camera. Supports custom update/render callbacks for test page injection
- `src/engine/input/InputManager.ts` — Keyboard input with action mapping (WASD + arrows + z/x/j), per-frame snapshot (pressed/held/released), input buffering with frame-based consume/check
- `src/engine/entities/Entity.ts` — Base entity class with position, velocity, size, color, interpolated rendering, AABB bounds
- `src/engine/entities/EntityManager.ts` — Entity registry with add/remove/get/iterate, batch update and render
- `src/engine/states/StateMachine.ts` — Generic FSM with enter/update/exit callbacks, time-in-state tracking, no-op on same-state transition
- `src/engine/physics/AABB.ts` — AABB utilities: overlap test, point containment, intersection rect, minimum-penetration resolution

### Files Modified (7):
- `src/lib/constants.ts` — Added INPUT_BUFFER_SIZE, DEFAULT_GRAVITY, MAX_FALL_SPEED, MAX_ACCUMULATOR_TIME, DEBUG_FONT, DEBUG_LINE_HEIGHT
- `src/lib/types.ts` — Added RenderLayer type, PerformanceMetrics interface
- `src/engine/core/index.ts` — Barrel exports for GameLoop, Renderer, Camera, Engine
- `src/engine/input/index.ts` — Barrel exports for InputManager, InputAction
- `src/engine/entities/index.ts` — Barrel exports for Entity, EntityConfig, EntityManager
- `src/engine/states/index.ts` — Barrel exports for StateMachine, State
- `src/engine/physics/index.ts` — Barrel exports for AABB utilities
- `src/engine/index.ts` — Top-level barrel re-exporting all engine modules

### Verification:
- `npx tsc --noEmit` — passes with zero errors
- `npm run build` — succeeds, all 27 pages generated

---

## Review Notes (reviewer: be938648)

### Issues Found and Fixed

1. **AABB `resolveAABB` zero-velocity edge case** (`src/engine/physics/AABB.ts`):
   When `velocity.x === 0` or `velocity.y === 0`, the push-out direction was ambiguous — it always pushed in the negative direction via the `else` branch. Fixed to use relative center positions as fallback when velocity is zero, so the entity is pushed away from the static object's center.

2. **InputManager `preventDefault` uses wrong key set** (`src/engine/input/InputManager.ts`):
   `GAME_KEYS` was a module-level constant computed from `DEFAULT_KEY_MAP`, so `preventDefault` would always check against default keys even when a custom `keyMap` was passed to the constructor. Fixed by making it an instance property (`this.gameKeys`) computed from the actual `this.keyMap`.

3. **Engine render — layer callbacks all fired in screen space** (`src/engine/core/Engine.ts`, `src/engine/core/Renderer.ts`):
   `renderLayers()` was called after `resetCamera()`, meaning ALL layer callbacks (including "background", "world", "entities", "fx") would render in screen space rather than camera space. Split rendering into `renderWorldLayers()` (background/world/entities/fx — rendered in camera space) and `renderScreenLayers()` (debug — rendered in screen space after camera reset).

### Things That Look Good

- **GameLoop**: Accumulator pattern is correct, spiral-of-death cap works, FPS smoothing is proper, interpolation factor calculation is right.
- **Camera**: Coordinate conversion math is correct in both directions. Viewport bounds calculation properly accounts for zoom.
- **Entity**: Interpolation is done correctly — `prevPosition` saved before position update, lerp in render.
- **StateMachine**: Clean implementation. No-op on same-state transition, time tracking resets on state change, proper enter/exit lifecycle.
- **InputManager**: Input buffering with frame-based consume is well implemented. Blur handler correctly releases all keys. Per-frame snapshot pattern ensures stable input during a tick.
- **Barrel exports**: All exports are correct and consistent.
- **Constants and types**: Values are reasonable. Types are clean.

### Post-review verification
- `npx tsc --noEmit` — passes with zero errors
- `npm run build` — succeeds
