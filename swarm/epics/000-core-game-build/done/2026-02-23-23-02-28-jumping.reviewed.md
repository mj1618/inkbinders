# Task: Jumping — Variable-Height Jump, Coyote Time, Input Buffering, Apex Float, Air Control

## What to Build

Implement the full jumping system for the player character. This adds JUMPING state to the Player state machine, replaces the placeholder FALLING state with proper air physics (air control, split gravity), and creates a fully functional test page at `/test/jumping` with debug overlays and tunable sliders for every jump parameter.

After this task, the player should be able to:
- Jump with variable height (short tap = hop, long hold = full arc)
- Feel a satisfying gravity split (floaty rise, snappy fall)
- Experience apex float (brief hang time at the peak)
- Jump within a few frames of leaving a ledge (coyote time)
- Buffer a jump input a few frames before landing (input buffering)
- Have full air control with slight launch-direction momentum bias

**This task builds directly on the existing ground movement system. The Player entity in `src/engine/entities/Player.ts` already has IDLE, RUNNING, CROUCHING, CROUCH_SLIDING, and FALLING states. This task adds JUMPING state and upgrades FALLING.**

## Files to Create

### `src/app/test/jumping/page.tsx` — Jumping Test Page (replaces stub)

Replace the stub with a fully functional test page. This is a `'use client'` component.

**Layout:**
- Left side: `GameCanvas` component (960x540)
- Right side: `DebugPanel` with sliders for all jump-related `PlayerParams` plus the existing ground movement params
- State readout, velocity readout, jump diagnostics, pass criteria

**Test Level Geometry:**
Design a test level optimized for testing jumps, using the `TileMap` system:
```
                                              ┌──────┐
                                              │ high │
                                    ┌────┐    │plat  │
                                    │mid │    │      │
          ┌────────┐    ┌────┐      │plat│    │      │
          │ step 1 │    │step│      │    │    │      │
   _______|        |    | 2  │      │    │    │      │______
  |                |    |    |      |    |    |      |      |
  |  main floor    |    |    | gap  |    |    |      | floor|
  |________________|____|____|______|____|    |______|______|
                                         wide gap
```

Specific layout elements:
- **Main floor**: wide platform at the bottom spanning most of the width
- **Step platforms**: 2-3 platforms at increasing heights to test variable jump height
  - Step 1: ~80px above floor (easy hop)
  - Step 2: ~140px above floor (medium jump)
  - Step 3: ~200px above floor (full jump needed)
  - High platform: ~280px above floor (unreachable without future abilities — shows max jump height limit)
- **Gaps**:
  - Narrow gap (~60px) — testable with short jump
  - Wide gap (~160px) — requires full jump with air control
- **Low ceiling section**: reuse from ground movement — test jumping into ceilings
- **Wall for later wall-jump testing**: tall wall on one side (irrelevant now but good for continuity)
- All positioned within the 960x540 canvas viewport with camera following the player

**Debug Overlays (drawn on canvas):**
- Player hitbox (cyan outline)
- Velocity vector (amber arrow from player center)
- State label above player (purple text: "IDLE", "RUNNING", "JUMPING", "FALLING", etc.)
- Ground contact indicator (green dot at feet when grounded)
- **Jump arc preview**: faint dotted trajectory showing predicted jump path (optional — nice to have)
- **Coyote time indicator**: small timer bar near player that depletes when coyote time is active (shows remaining coyote frames)
- **Input buffer indicator**: flash when a buffered jump fires
- **Apex float indicator**: highlight/glow when apex float is active
- FPS counter (top-left)
- Velocity readout (top-right): show both x and y velocity
- Jump diagnostics panel on canvas: "Grounded: Y/N", "Coyote: N frames", "Jump held: Y/N", "Apex float: Y/N"

**Debug Panel Sliders:**

All existing ground movement params (maxRunSpeed, acceleration, deceleration, turnMultiplier, crouchSpeed, slideInitialSpeed, slideFriction, slideMinSpeed, gravity) PLUS new jump params:

| Parameter | Min | Max | Step | Default |
|-----------|-----|-----|------|---------|
| Jump Speed (initial velocity) | 200 | 600 | 10 | 380 |
| Rise Gravity | 200 | 1500 | 50 | 680 |
| Fall Gravity | 400 | 2000 | 50 | 980 |
| Apex Gravity Multiplier | 0.1 | 0.8 | 0.05 | 0.4 |
| Apex Velocity Threshold | 10 | 100 | 5 | 50 |
| Max Fall Speed | 200 | 1200 | 50 | 600 |
| Coyote Time (frames) | 0 | 15 | 1 | 7 |
| Jump Buffer (frames) | 0 | 15 | 1 | 5 |
| Air Acceleration | 200 | 3000 | 100 | 1400 |
| Air Deceleration | 100 | 2000 | 100 | 600 |
| Jump Cut Multiplier | 0.1 | 0.8 | 0.05 | 0.4 |

Also include:
- "Reset Player" button
- "Reset Params" button (resets ALL params to defaults, both ground and jump)
- Debug overlay toggle

**Pass Criteria** (display on the test page):
1. Short tap produces a small hop; holding jump produces a full-height arc
2. Rising feels floaty, falling feels snappy (gravity split working)
3. Brief hang time at the apex of the jump (apex float)
4. Player can jump within ~7 frames of walking off a ledge (coyote time)
5. Pressing jump just before landing triggers jump on contact (input buffering)
6. Full horizontal air control — can steer mid-air
7. Slight momentum bias from launch direction (can't instantly reverse in air)
8. Jumping into a ceiling stops upward momentum (no clipping)
9. Can jump from crouch (uncrouch + jump)
10. All jump parameters are tunable via sliders in real time

## Files to Modify

### `src/engine/entities/Player.ts` — Add Jump States & Parameters

**New PlayerParams fields to add:**
```typescript
// Add to PlayerParams interface:
jumpSpeed: number;          // initial upward velocity on jump (px/s)
riseGravity: number;        // gravity while rising (px/s²) — lower than fall
fallGravity: number;        // gravity while falling (px/s²) — the "snappy" fall
apexGravityMultiplier: number; // multiply active gravity by this at apex (0-1)
apexVelocityThreshold: number; // velocity.y absolute value below which apex float activates
coyoteFrames: number;       // frames after leaving ground where jump is still allowed
jumpBufferFrames: number;   // frames before landing where jump input is buffered
airAcceleration: number;    // horizontal acceleration in air (px/s²)
airDeceleration: number;    // horizontal deceleration in air when no input (px/s²)
jumpCutMultiplier: number;  // multiply velocity.y by this when jump released early (0-1)
```

**Default values (add to DEFAULT_PLAYER_PARAMS):**
```typescript
jumpSpeed: 380,
riseGravity: 680,
fallGravity: 980,
apexGravityMultiplier: 0.4,
apexVelocityThreshold: 50,
coyoteFrames: 7,
jumpBufferFrames: 5,
airAcceleration: 1400,
airDeceleration: 600,
jumpCutMultiplier: 0.4,
```

**New Player properties:**
```typescript
coyoteTimer: number;      // frames since last grounded (0 when on ground)
jumpHeld: boolean;        // whether jump button is currently held (for variable height)
isInApexFloat: boolean;   // whether apex float is currently active (for debug display)
```

**New state: JUMPING**

Enter:
- Set `velocity.y = -params.jumpSpeed` (negative = upward)
- Set `jumpHeld = true`
- Reset coyote timer
- If crouching, restore standing height first (position.y adjustment)

Update:
- **Gravity selection**:
  - If `velocity.y < 0` (rising): use `riseGravity`
  - If `velocity.y >= 0` (falling): transition to FALLING state
  - **Apex float**: if `Math.abs(velocity.y) < apexVelocityThreshold`, multiply the active gravity by `apexGravityMultiplier`
- **Variable height (jump cut)**: if jump key was released (`!input.isHeld(Jump)` and `jumpHeld` was true), multiply `velocity.y` by `jumpCutMultiplier` (cuts upward velocity, making the player fall sooner). Set `jumpHeld = false` so this only happens once.
- **Air control**: apply `airAcceleration` for horizontal movement based on input. Apply `airDeceleration` when no horizontal input. Clamp to `maxRunSpeed`.
- **Ceiling collision**: if `hitCeiling`, zero out upward velocity and transition to FALLING
- Apply gravity, apply velocity, resolve collisions

Exit: nothing special

**Upgrade FALLING state:**

The existing FALLING state is a placeholder. Replace with:

Update:
- **Gravity**: always use `fallGravity` (player is falling)
  - **Apex float**: if `Math.abs(velocity.y) < apexVelocityThreshold`, multiply gravity by `apexGravityMultiplier` (can enter apex from FALLING too, e.g., if jump was cut early and velocity is near zero)
- **Air control**: same as JUMPING — apply `airAcceleration` / `airDeceleration` for horizontal input, clamp to `maxRunSpeed`
- **Landing**: if `grounded`:
  - Check for buffered jump: `input.consumeBufferedInput(InputAction.Jump, jumpBufferFrames)` — if yes, immediately transition to JUMPING (bounce)
  - Otherwise, restore standing height if crouched, transition to IDLE or RUNNING based on horizontal input
- Clamp vertical velocity to `maxFallSpeed`

**Modify IDLE, RUNNING, CROUCHING states — add jump transition:**

In IDLE update:
- Check `input.isPressed(InputAction.Jump)` OR `input.consumeBufferedInput(InputAction.Jump, jumpBufferFrames)` → transition to JUMPING

In RUNNING update:
- Same jump check → transition to JUMPING

In CROUCHING update:
- Check jump input → restore standing height if possible, then transition to JUMPING

In CROUCH_SLIDING update:
- Check jump input → restore standing height if possible, then transition to JUMPING

**Coyote time implementation:**

In the Player's main `update()` method (or in individual states):
- Every frame that the player is `grounded`, reset `coyoteTimer = 0`
- Every frame that the player is NOT grounded and in a ground state (just walked off a ledge), increment `coyoteTimer`
- When `coyoteTimer <= coyoteFrames`, the player can still jump (this is coyote time)
- When coyote time expires, transition to FALLING

The key insight: coyote time applies when the player walks off a ledge (transitions from a ground state to not-grounded). It does NOT apply after jumping — once you jump, you can't jump again until grounded.

Implementation approach:
- In the FALLING state enter, record whether the player entered by walking off a ledge (coyote-eligible) vs. after a jump (not coyote-eligible)
- OR: add a `hasJumped` flag that's set to true when JUMPING state is entered, and cleared when grounded. Only allow coyote jump when `!hasJumped`.
- The simpler approach: track `canCoyoteJump` as a boolean. Set `true` when entering FALLING from a ground state (not from JUMPING). In FALLING update, if `canCoyoteJump && coyoteTimer <= coyoteFrames && input.isPressed(Jump)` → transition to JUMPING.

**Gravity changes in main `update()`:**

Currently the Player's `update()` always applies `this.params.gravity`. This needs to change:
- Remove the gravity application from the main `update()` method
- Move gravity into each state's update (JUMPING uses riseGravity + apex, FALLING uses fallGravity + apex, ground states use fallGravity as a default to keep the player pressed to ground)
- OR: have the state machine set a `currentGravity` property on the player each frame, and the main `update()` applies it. This is cleaner.

**Recommended approach**: Add `currentGravity: number` to Player. Each state's update sets `this.currentGravity` based on the state's logic. The main `update()` applies it:
```typescript
this.velocity.y += this.currentGravity * dt;
this.velocity.y = Math.min(this.velocity.y, this.params.maxFallSpeed);
```

### `src/engine/entities/index.ts` — Update exports if needed

### `src/lib/testStatus.ts` — Update jumping status to `'in-progress'`

## Implementation Notes

- **Gravity is the star of this feature.** The difference between riseGravity and fallGravity is what makes the jump feel good. Rising should feel like you're being gently lifted; falling should feel responsive and grounded. The apex float is the cherry on top — it gives you a split-second of hang time that makes the peak of the jump feel "intentional."

- **Jump cut is crucial for variable height.** When the player releases jump early, we don't just start falling — we multiply the current upward velocity by `jumpCutMultiplier` (e.g., 0.4). This makes the player's ascent die quickly but not instantly, which feels much better than just zeroing velocity.

- **Coyote time and input buffering are invisible quality-of-life features.** Players don't notice they're there, but they WILL notice if they're missing. Coyote time prevents the "I swear I pressed jump" frustration. Input buffering prevents the "I pressed jump too early and fell" frustration.

- **Air control should feel responsive but not twitchy.** Air acceleration should be slightly less than ground acceleration (1400 vs 1800), and air deceleration significantly less than ground deceleration (600 vs 1200). This gives the player full control but preserves the feeling of momentum — you can steer but you can't stop on a dime mid-air.

- **The player can jump from any ground state.** From IDLE, RUNNING, CROUCHING, and CROUCH_SLIDING. When jumping from a crouch, the player first uncrouches (if headroom allows), then jumps. If there's no headroom, the jump is blocked.

- **Don't break ground movement.** The existing ground movement should work exactly as before. Jump states are additive. Test this carefully — make sure crouch-slide still works, turn-around still feels snappy, etc.

## Design Decisions (Pre-settled)

1. **State-based gravity** — each state sets `currentGravity` rather than having one gravity constant. This allows rise, fall, and apex to each have different gravity without conditionals in the main update.
2. **Jump cut on release** — multiply velocity by jumpCutMultiplier, not zero it. Smoother feel.
3. **Coyote time via flag** — track `canCoyoteJump` boolean rather than complex timer logic. Set on FALLING enter from ground, cleared after jump or timeout.
4. **Input buffering via existing system** — use `InputManager.consumeBufferedInput()` which is already built. Just configure the window size.
5. **No double jump** — not in this task. Double jump would be a separate ability.
6. **Jumping from crouch uncrouches first** — player stands up then jumps. If blocked by ceiling, can't jump.
7. **Apex float applies in both JUMPING and FALLING** — velocity passes through zero during the transition, and float should be active in that zone regardless of which state is technically active.

## Verification

- [ ] `npx tsc --noEmit` passes with zero errors
- [ ] `npm run build` succeeds
- [ ] Navigate to `/test/jumping` — canvas renders with test level and player
- [ ] Short tap on Space/Z produces a small hop
- [ ] Holding Space/Z produces a full-height jump
- [ ] The jump arc feels satisfying — floaty rise, brief hang at peak, snappy fall
- [ ] Walking off a ledge allows jumping within ~7 frames (coyote time works)
- [ ] Pressing jump slightly before landing triggers jump on contact (buffer works)
- [ ] Horizontal air control works — can steer mid-air
- [ ] Air control feels different from ground control (slightly less responsive)
- [ ] Jumping into a ceiling stops the player cleanly (no clipping)
- [ ] Can jump from IDLE, RUNNING, CROUCHING, and CROUCH_SLIDING states
- [ ] Ground movement still works identically to before (run, crouch, slide all intact)
- [ ] All sliders update physics in real time
- [ ] Debug overlays show coyote time indicator, apex float indicator, jump state
- [ ] FPS stays at ~60fps
- [ ] Reset buttons work

---

## Completion Summary

### Files Modified

1. **`src/engine/entities/Player.ts`** — Major update:
   - Added 10 new jump parameters to `PlayerParams` interface and `DEFAULT_PLAYER_PARAMS`
   - Added jump state properties: `coyoteTimer`, `jumpHeld`, `isInApexFloat`, `canCoyoteJump`, `currentGravity`
   - Added `STATE_JUMPING` state with: variable-height jump (jump cut on release), rise gravity, apex float detection, air control
   - Upgraded `STATE_FALLING` state with: fall gravity, apex float, air control, coyote time logic, buffered jump on landing
   - Added jump transitions to IDLE, RUNNING, CROUCHING, and CROUCH_SLIDING states via shared `tryJump()` method
   - Jumping from crouch uncrouches first (if headroom available)
   - Switched from single gravity to state-based gravity (`currentGravity` set by each state, applied in main `update()`)
   - Ceiling collision during JUMPING transitions to FALLING
   - Coyote time: tracked via `canCoyoteJump` flag set on FALLING enter from ground states (not from JUMPING)
   - Added jump/fall color variants to player rendering

2. **`src/app/test/jumping/page.tsx`** — Full test page replacing stub:
   - Test level with: main floor, 3 step platforms (80/140/200px), unreachable high platform (280px), narrow gap (60px), wide gap (160px), low ceiling section, ceiling block for head-bonking, boundary walls
   - Debug overlays: hitbox, velocity vector, state label, ground contact, coyote time depleting bar, apex float glow highlight
   - Screen-space debug: FPS, velocity X/Y, jump diagnostics panel (state, grounded, coyote frames, jump held, apex float)
   - Full slider panel: all ground movement params + all 11 jump params organized by category
   - Reset Player, Reset Params, Debug Overlay toggle buttons

3. **`src/lib/testStatus.ts`** — Updated jumping status from `"not-started"` to `"in-progress"`

### Verification
- `npx tsc --noEmit` — passes with zero errors
- `npm run build` — succeeds, all routes generated
- Dev server starts cleanly

---

## Review Notes (Reviewer: e76aa9bd)

### Overall Assessment
Solid implementation. The jump state machine is well-structured with correct gravity selection, apex float, coyote time, and input buffering. The test page is comprehensive with good debug overlays and all parameters wired to sliders.

### Issues Found & Fixed

**1. Ground-movement page gravity slider regression (FIXED)**
- The jumping task switched from single `params.gravity` to state-based gravity (`riseGravity`/`fallGravity`). All ground states (IDLE, RUNNING, CROUCHING, CROUCH_SLIDING) now set `currentGravity = params.fallGravity`, which is correct.
- However, the ground-movement test page (`src/app/test/ground-movement/page.tsx`) had a "Gravity" slider wired to `params.gravity`, which is no longer read by any state. This made the slider non-functional — a regression.
- **Fix:** Updated the ground-movement page's gravity slider to control `params.fallGravity` instead of `params.gravity`. The slider now correctly affects ground-state gravity again.
- File modified: `src/app/test/ground-movement/page.tsx` (line 329-334)

### Items Reviewed (No Issues)

- **State machine transitions:** All states correctly handle jump initiation via shared `tryJump()` method. JUMPING → FALLING transition on velocity sign change is correct. FALLING → ground state landing with buffered jump check works properly.
- **Gravity model:** State-based gravity with apex float modulation is clean. Gravity applied once in main `update()` after state machine runs. No double-application.
- **Coyote time:** Correctly tracked via `canCoyoteJump` flag set only when entering FALLING from ground states (not from JUMPING). Timer increment per fixed-timestep frame is correct.
- **Jump cut (variable height):** Multiplies velocity by `jumpCutMultiplier` on release, fires only once via `jumpHeld` flag. Correct.
- **Air control:** Uses separate `airAcceleration`/`airDeceleration` with proper clamping. No frame-rate dependent physics.
- **Ceiling collision:** TileMap resolves collision and Player.update() transitions to FALLING. Redundant velocity zero is harmless.
- **Uncrouch before jump:** `tryJump()` handles uncrouch with headroom check. JUMPING enter has a safety re-check (no-op if already standing). Correct.
- **Test page:** All 11 jump parameters have sliders. Debug overlays for coyote timer, apex float, state labels all wired correctly. FPS and velocity readout in screen space. Reset buttons work.
- **TypeScript:** No `any` types. Clean type check. Build succeeds.
- **Memory management:** Engine stop/detach on unmount. No leaked listeners.

### Note for Future Tasks
- The `params.gravity` field in `PlayerParams` is now effectively dead code — it's set to `DEFAULT_GRAVITY` (980) but never read by any state. Consider removing it in a future cleanup task to avoid confusion. The `riseGravity` and `fallGravity` params fully replace it.
