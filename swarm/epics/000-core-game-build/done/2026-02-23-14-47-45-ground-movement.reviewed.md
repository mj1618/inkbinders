# Task: Ground Movement — Player Entity, Ground Physics, and Test Page

## What to Build

Implement the first real gameplay feature: ground movement. This creates a Player entity with a state machine for ground states (Idle, Running, Crouching, CrouchSliding), ground physics with acceleration/deceleration curves, and a fully functional test page at `/test/ground-movement` with debug overlays and tunable sliders.

This task also creates a simple static platform/tilemap system for collision, since the player needs ground to stand on.

**After this task, you should be able to run around on platforms, crouch, and crouch-slide under gaps — and tune every physics value in real time.**

## Files to Create

### `src/engine/entities/Player.ts` — Player Entity

The player character entity. Extends `Entity` from `src/engine/entities/Entity.ts`.

**Properties (beyond base Entity):**
- `grounded: boolean` — whether the player is touching ground this frame
- `facingRight: boolean` — direction the player is facing
- `stateMachine: StateMachine<Player>` — FSM for player states
- `params: PlayerParams` — all tunable physics parameters (see below)

**PlayerParams interface** (define in this file or in types):
```typescript
export interface PlayerParams {
  maxRunSpeed: number;       // max horizontal speed when running (px/s)
  acceleration: number;      // horizontal acceleration (px/s²)
  deceleration: number;      // horizontal deceleration when no input (px/s²)
  turnMultiplier: number;    // acceleration multiplied by this when reversing direction
  crouchSpeed: number;       // max horizontal speed when crouching (px/s)
  slideInitialSpeed: number; // starting speed of crouch-slide (px/s)
  slideFriction: number;     // deceleration during crouch-slide (px/s²)
  slideMinSpeed: number;     // speed below which slide ends (px/s)
  gravity: number;           // gravity (px/s²)
  maxFallSpeed: number;      // terminal velocity (px/s)
  playerWidth: number;       // hitbox width (px)
  playerHeight: number;      // hitbox height when standing (px)
  crouchHeight: number;      // hitbox height when crouching (px)
}
```

**Default values (starting points — all tunable via sliders):**
- `maxRunSpeed`: 280
- `acceleration`: 1800
- `deceleration`: 1200
- `turnMultiplier`: 3.0
- `crouchSpeed`: 100
- `slideInitialSpeed`: 350
- `slideFriction`: 600
- `slideMinSpeed`: 40
- `gravity`: 980 (use `DEFAULT_GRAVITY` from constants)
- `maxFallSpeed`: 600 (use `MAX_FALL_SPEED` from constants)
- `playerWidth`: 24
- `playerHeight`: 40
- `crouchHeight`: 24

**Player State Machine (ground states only — jumping/wall/dash come in later tasks):**

1. **Idle** — No horizontal input, on ground
   - Enter: set horizontal velocity toward zero (apply deceleration)
   - Update: if horizontal input → Running; if crouch input → Crouching; apply gravity if not grounded (→ Falling placeholder)
   - Render: standing rectangle

2. **Running** — Horizontal input held, on ground
   - Enter: nothing special
   - Update:
     - Apply acceleration in input direction
     - If turning (input opposite to velocity), multiply acceleration by `turnMultiplier` for snappy turns
     - Clamp horizontal speed to `maxRunSpeed`
     - If no horizontal input → Idle
     - If crouch input while speed > `slideMinSpeed` → CrouchSliding (preserves momentum)
     - If crouch input while speed ≤ `slideMinSpeed` → Crouching
     - Apply gravity if not grounded
   - Render: standing rectangle, slightly different shade when at full speed

3. **Crouching** — Crouch held, on ground, low/no speed
   - Enter: reduce hitbox height to `crouchHeight`, adjust position so feet stay on ground
   - Update:
     - Allow slow horizontal movement at `crouchSpeed`
     - Apply deceleration if no horizontal input
     - If crouch released AND there's headroom → Idle or Running (check horizontal input)
     - If crouch released BUT blocked above → stay crouching (can't stand up)
   - Exit: restore hitbox height to `playerHeight` (only if there's room)
   - Render: shorter rectangle

4. **CrouchSliding** — Initiated from running + crouch, decelerating slide
   - Enter: set hitbox to `crouchHeight`, set slide speed to current horizontal speed (or `slideInitialSpeed`, whichever is lower)
   - Update:
     - Apply `slideFriction` to decelerate
     - If speed drops below `slideMinSpeed` → Crouching
     - If crouch released AND there's headroom → Running or Idle
     - Player cannot accelerate during slide (input is ignored for horizontal movement)
     - Can pass under low ceilings
   - Exit: restore hitbox if room
   - Render: shorter rectangle, motion blur indicator (just a trailing ghost rectangle for now)

**Important implementation notes:**
- The player does NOT handle jumping, wall mechanics, or dashing yet. If the player walks off a ledge, they should simply fall with gravity until they hit ground (a basic "Falling" state placeholder — no air control yet, that comes in the jumping task).
- Turn-around should feel instant: when input reverses, apply `acceleration * turnMultiplier` toward the new direction. The deceleration of the old direction + acceleration of the new direction combined make it feel snappy.
- Keep the `update` method clean: the state machine's `update` callback handles state-specific logic, and the Player's `update` method handles common concerns (gravity, collision resolution).
- Store `prevPosition` before applying velocity for interpolation (base Entity already does this).

### `src/engine/physics/TileMap.ts` — Simple Static Collision Geometry

A minimal tilemap/platform system for test levels. This does NOT need to be a full tile engine — it's a collection of static axis-aligned rectangles that entities can collide with.

```typescript
export interface Platform {
  x: number;
  y: number;
  width: number;
  height: number;
}

export class TileMap {
  platforms: Platform[];

  constructor(platforms: Platform[]);

  // Check if a rect overlaps any platform
  checkCollision(bounds: Rect): Platform | null;

  // Resolve an entity's position against all platforms
  // Returns: { grounded: boolean, hitCeiling: boolean, hitWall: boolean }
  resolveCollisions(entity: { position: Vec2, velocity: Vec2, size: Vec2 }): CollisionResult;

  // Check if there's enough room to stand up at a position
  hasHeadroom(position: Vec2, standingHeight: number, crouchHeight: number): boolean;

  // Render all platforms (for debug/test)
  render(renderer: Renderer): void;
}
```

**Collision resolution approach:**
- After the entity moves, check overlap with each platform
- Use minimum-penetration push-out (leverage existing AABB utilities)
- Resolve Y-axis collisions first (ground/ceiling), then X-axis (walls)
- Set `grounded = true` if resolved downward (pushed up off a platform's top surface)
- Set `hitCeiling = true` if resolved upward
- Zero out the appropriate velocity component on collision
- This is intentionally simple — a more sophisticated system can replace it later

### `src/app/test/ground-movement/page.tsx` — Real Test Page (replaces stub)

Replace the stub with a fully functional test page. This is a `'use client'` component.

**Layout:**
- Left side: `GameCanvas` component (960x540)
- Right side: `DebugPanel` with sliders for all `PlayerParams` values
- Below canvas or in debug panel: state readout, velocity readout, pass criteria checklist

**Test Level Geometry:**
Design a simple test level using the `TileMap` system:
- Main floor: full-width platform at the bottom
- Elevated platform on the right (jump height TBD — for now, player can't jump, so make it reachable by falling from higher platform or just have it for visual reference)
- A low ceiling section that requires crouching/sliding to pass through (ceiling gap should be ~26px, between `crouchHeight` (24) and `playerHeight` (40))
- A pit/gap in the floor (the player will fall in — that's fine, it tests falling)
- Dimensions in world pixels, positioned relative to a ground level

**ASCII sketch of test level:**
```
                    ___________
                   |           |     <- low ceiling (requires crouch-slide)
         ______   |  ceiling   |   _______
        |      |  |___________|  |       |
        |      |                 |       |
   _____|      |_____       _____|       |_______
  |                  |     |                     |
  |   main floor     | gap |    main floor       |
  |__________________|     |_____________________|
```

**Debug Overlays (drawn on the canvas):**
- Player hitbox (cyan outline)
- Velocity vector (amber arrow from player center, length proportional to speed)
- State label above player (purple text: "IDLE", "RUNNING", "CROUCHING", "CROUCH_SLIDING")
- Ground contact indicator (green dot at player's feet when grounded)
- Platform outlines (green rectangles)
- FPS counter (top-left corner)
- Current speed readout on canvas (top-right)

**Debug Panel Sliders:**
Every value from `PlayerParams`:
- Max Run Speed: 50–600, step 10
- Acceleration: 200–5000, step 100
- Deceleration: 200–3000, step 100
- Turn Multiplier: 1.0–6.0, step 0.5
- Crouch Speed: 20–200, step 10
- Slide Initial Speed: 100–600, step 10
- Slide Friction: 100–1500, step 50
- Slide Min Speed: 10–100, step 5
- Gravity: 200–2000, step 50
- Max Fall Speed: 200–1200, step 50

Also include:
- A "Reset Player" button that repositions the player to spawn point
- A "Reset Params" button that resets all sliders to defaults
- A toggle for debug overlay visibility

**Pass Criteria** (display on the test page):
1. Player accelerates smoothly from stop to max speed (no teleporting, no jitter)
2. Deceleration produces a tiny satisfying slide, not ice-skating
3. Turn-around feels instant — reversing direction is snappy, not floaty
4. Crouch reduces hitbox height and allows passing under low ceilings
5. Crouch-slide maintains momentum and decelerates naturally
6. Crouch-slide can pass under gaps that standing cannot
7. Player cannot stand up when blocked by ceiling above
8. Player falls when walking off a ledge (gravity works)
9. All sliders update physics in real time
10. Debug overlays correctly show hitbox, velocity, state, and ground contact

### Files to Modify

- `src/engine/entities/index.ts` — Add `Player` and `PlayerParams` to barrel exports
- `src/engine/physics/index.ts` — Add `TileMap`, `Platform`, `CollisionResult` to barrel exports
- `src/lib/testStatus.ts` — Update ground-movement status to `'in-progress'`

## Wiring It All Together

In the test page's `onMount` callback:
1. Create an `Engine` instance with the canvas context
2. Create a `TileMap` with the test level geometry
3. Create a `Player` entity at the spawn point
4. Add the player to the engine's entity manager
5. Register a custom update callback that:
   - Reads input from the engine's `InputManager`
   - Passes input to the player's state machine
   - Runs `tileMap.resolveCollisions(player)` after the player updates
6. Register a custom render callback that:
   - Draws the tilemap platforms
   - Draws debug overlays (hitbox, velocity, state, ground indicator)
   - Draws FPS and speed readouts
7. Start the engine

The React component uses `useRef` to hold a reference to the player and `useState` for slider values. When a slider changes, update `player.params` directly via the ref — no re-render needed for the engine to pick up the new values.

## Implementation Notes

- The Player entity should NOT import anything from React. All communication between React (sliders) and engine (player) happens through the `PlayerParams` object reference.
- The `TileMap.render()` method draws platforms as filled rectangles with a border — use the debug ground color from constants.
- The state machine context is the Player instance itself (`StateMachine<Player>`).
- For the "Falling" placeholder state: just apply gravity and air drift (no friction/deceleration in air). The full jumping task will replace this with proper air control, coyote time, etc.
- When the player falls into the pit, let them fall. The test page should have a "Reset Player" button. Optionally, auto-respawn if the player falls below a Y threshold.

## Design Decisions (Pre-settled)

1. **Player as a class extending Entity** — keeps it simple, overrides `update` and `render`.
2. **PlayerParams as a mutable object** — React sliders write to it directly via ref, engine reads it every frame. No event system needed.
3. **TileMap is a flat list of rectangles** — not a grid-based tilemap. Simpler for test levels, and a grid system can be built on top later if needed.
4. **Y-then-X collision resolution** — resolving vertical first prevents ground detection issues when sliding along walls.
5. **Falling is a minimal placeholder** — just gravity + momentum, no air control. The jumping task will properly implement air physics.
6. **No sprites yet** — player is a colored rectangle. Sprite system comes later.
7. **Turn-around is frame-instant** — no turn animation or deceleration-then-accelerate. The high `turnMultiplier` on acceleration makes it feel snappy without literally snapping velocity.

## Verification

- [x] `npx tsc --noEmit` passes with zero errors
- [x] `npm run build` succeeds
- [ ] Navigate to `/test/ground-movement` — canvas renders with test level and player
- [ ] Arrow keys / WASD move the player left and right with smooth acceleration
- [ ] Releasing movement keys produces a short deceleration slide
- [ ] Turning around (holding opposite direction) feels snappy
- [ ] Down arrow / S key crouches the player (hitbox shrinks)
- [ ] Running + crouch triggers a crouch-slide that decelerates
- [ ] Crouch-slide passes under the low ceiling section
- [ ] Player cannot stand up under the low ceiling
- [ ] Walking off a ledge causes the player to fall
- [ ] All debug overlays render correctly (hitbox, velocity, state, ground)
- [ ] All sliders update physics values in real time
- [ ] FPS counter shows ~60fps
- [ ] Reset buttons work

---

## Completion Summary

### Files Created
- **`src/engine/entities/Player.ts`** — Player entity with StateMachine (IDLE, RUNNING, CROUCHING, CROUCH_SLIDING, FALLING states), PlayerParams interface with all tunable values, acceleration/deceleration curves, turn multiplier, crouch/slide mechanics, canStandUp headroom check, gravity, and collision integration via TileMap.
- **`src/engine/physics/TileMap.ts`** — Simple platform collision system with Y-then-X resolution, checkCollision, resolveCollisions (returns grounded/hitCeiling/hitWall), hasHeadroom, and debug rendering.

### Files Modified
- **`src/app/test/ground-movement/page.tsx`** — Replaced TestPageStub with full test page: GameCanvas + DebugPanel with 10 sliders (movement, crouch/slide, physics), debug overlays (hitbox, velocity vector, state label, ground contact, FPS, speed), Reset Player/Params buttons, debug overlay toggle, auto-respawn on fall. Test level has main floor sections, gap, elevated platforms, low ceiling section (26px gap for crouch-slide).
- **`src/engine/entities/index.ts`** — Added Player, DEFAULT_PLAYER_PARAMS, and PlayerParams exports.
- **`src/engine/physics/index.ts`** — Added TileMap, Platform, and CollisionResult exports.
- **`src/engine/index.ts`** — Added Player, TileMap, and related type exports.
- **`src/lib/testStatus.ts`** — Updated ground-movement status to "in-progress".

### Key Design Decisions
- Player.input and Player.tileMap are set by the test page (dependency injection via refs), keeping the engine code React-free.
- Crouch enter/slide enter guard against double-shrinking when transitioning between crouch states.
- Falling state preserves crouch height during fall; landing restores standing height with position adjustment.
- Input uses InputAction.Down (mapped to ArrowDown/S) for crouch since InputAction.Crouch has no default key mapping.
- Debug overlays render in world space (camera-aware) via engine.onRender; FPS/speed render in screen space via debug layer callback.

### Verified
- `npx tsc --noEmit` — zero errors
- `npm run build` — succeeds, all 27 pages generated
- Dev server starts and compiles the test page

---

## Review (Reviewer: 933d3e54)

### Files Reviewed
- `src/engine/entities/Player.ts`
- `src/engine/physics/TileMap.ts`
- `src/app/test/ground-movement/page.tsx`
- `src/engine/entities/index.ts`
- `src/engine/physics/index.ts`
- `src/engine/index.ts`
- `src/lib/testStatus.ts`

### Issues Found and Fixed

**1. FALLING state landing without headroom check (Player.ts, FALLING state update)**
- **Problem**: When the player falls while crouching (e.g., walks off a ledge while crouched) and lands in a tight space with a low ceiling, the FALLING state unconditionally restored standing height (`playerHeight`) on landing. This could push the player's position up into a ceiling, causing clipping or jitter after collision resolution.
- **Fix**: Added a `canStandUp()` check before restoring standing height. If there's no headroom, the player transitions to CROUCHING instead of IDLE/RUNNING, keeping the crouched hitbox. This prevents clipping into ceilings and is consistent with how the CROUCHING state handles the "can't stand up" scenario.

### No Issues (Looked Good)
- **State machine completeness**: All 5 states (IDLE, RUNNING, CROUCHING, CROUCH_SLIDING, FALLING) have correct transitions. No stuck states possible — every state can transition to at least one other state.
- **Physics correctness**: All physics values use `dt` multiplication — no frame-rate dependent movement. Gravity, acceleration, deceleration, and slide friction all scale correctly with delta time.
- **Turn-around feel**: Correctly applies `acceleration * turnMultiplier` when input opposes velocity direction. Combined with natural deceleration of old velocity, this creates snappy reversal.
- **Collision resolution**: Y-then-X order is correct. Direction detection uses velocity with center-position fallback for zero velocity.
- **Crouch height guards**: Both CROUCHING and CROUCH_SLIDING enter states check `size.y > crouchHeight` before shrinking, preventing double-shrink when transitioning between crouch states.
- **Slider wiring**: All 10 PlayerParams values have corresponding sliders. The `updateParam` callback writes directly to `player.params` via ref — no React re-render needed for the engine to see changes.
- **Memory management**: Engine is stopped and dereferenced on unmount. Layer callbacks are not explicitly removed, but this is fine since the entire engine is GC'd.
- **TypeScript**: No `any` escape hatches. The `EngineWithOverlayRef` interface properly types the overlay ref hack.
- **Test level geometry**: Low ceiling gap is 26px (420 - 394), correctly between crouchHeight (24) and playerHeight (40).
- **Barrel exports**: Correctly re-export Player, PlayerParams, DEFAULT_PLAYER_PARAMS, TileMap, Platform, CollisionResult from the appropriate index files.

### Post-Review Verification
- `npx tsc --noEmit` — zero errors
- `npm run build` — succeeds, all 27 pages generated
