# Task: Wall Mechanics — Wall-Slide with Graduated Friction, Wall-Jump with Input Lockout

## What to Build

Implement wall-slide and wall-jump mechanics for the player character, and create a fully functional test page at `/test/wall-mechanics` with debug overlays and tunable sliders.

After this task, the player should be able to:
- Slide down walls at a controlled speed that varies based on input (graduated friction)
- Wall-jump off surfaces with a fixed launch angle and brief input lockout
- Chain wall-jumps rhythmically between two walls (the "wall-jump corridor" feel)
- Combine wall mechanics seamlessly with existing ground movement and jumping

**This task builds on the existing Player entity (6 states: IDLE, RUNNING, CROUCHING, CROUCH_SLIDING, JUMPING, FALLING). It adds WALL_SLIDING and WALL_JUMPING states.**

## Prerequisites

The existing codebase has:
- `TileMap.resolveCollisions()` returns `{ grounded, hitCeiling, hitWall }` — but `hitWall` is a boolean with no side information
- Player already has full ground movement and jumping
- `InputManager` has `isHeld`, `isPressed`, buffering
- `StateMachine` supports arbitrary states with enter/update/exit

## Changes Needed

### 1. Enhance `CollisionResult` in `src/engine/physics/TileMap.ts`

The current `CollisionResult` only has `hitWall: boolean`. Wall mechanics need to know **which side** the wall is on. Update:

```typescript
export interface CollisionResult {
  grounded: boolean;
  hitCeiling: boolean;
  hitWall: boolean;
  wallDirection: -1 | 0 | 1; // -1 = wall on left, 0 = no wall, 1 = wall on right
}
```

In `resolveCollisions()`, when resolving X-axis collisions:
- If the entity was pushed left (wall on right), set `wallDirection = 1`
- If the entity was pushed right (wall on left), set `wallDirection = -1`
- If no wall collision, `wallDirection = 0`

Also add a helper method needed for wall detection:

```typescript
/** Check if the entity is touching a wall on a specific side */
isTouchingWall(entity: { position: Vec2; size: Vec2 }, side: -1 | 1): boolean
```

This checks if there's a platform immediately adjacent to the entity on the specified side (within 1-2 pixels). This is needed because after collision resolution, the entity is no longer overlapping the wall — we need to check adjacency.

Implementation: create a thin probe rect (1px wide) on the specified side of the entity's bounds and check if it overlaps any platform.

### 2. Add Wall Parameters to `PlayerParams` in `src/engine/entities/Player.ts`

Add these fields to the `PlayerParams` interface:

```typescript
// Wall mechanics parameters
wallSlideBaseSpeed: number;     // max slide speed when just touching wall (px/s)
wallSlideGripSpeed: number;     // max slide speed when holding toward wall (px/s) — slower = more grip
wallSlideAcceleration: number;  // how quickly slide speed ramps to max (px/s²)
wallJumpHorizontalSpeed: number; // horizontal launch speed for wall-jump (px/s)
wallJumpVerticalSpeed: number;   // vertical launch speed for wall-jump (px/s)
wallJumpLockoutFrames: number;  // frames of input lockout after wall-jump (prevents immediate re-stick)
wallJumpCoyoteFrames: number;   // frames after leaving wall where wall-jump is still allowed
wallStickFrames: number;        // frames of "sticking" to wall on initial contact (brief pause)
```

Add these defaults to `DEFAULT_PLAYER_PARAMS`:

```typescript
wallSlideBaseSpeed: 120,        // Slide speed when touching wall (not holding toward)
wallSlideGripSpeed: 40,         // Slide speed when holding toward wall (gripping)
wallSlideAcceleration: 800,     // Ramp speed — fast enough to feel responsive
wallJumpHorizontalSpeed: 260,   // Horizontal kick-off — should feel punchy
wallJumpVerticalSpeed: 340,     // Vertical boost — slightly less than ground jump for balance
wallJumpLockoutFrames: 8,       // ~133ms at 60Hz — short enough to feel responsive, long enough to prevent cheese
wallJumpCoyoteFrames: 5,        // ~83ms — forgiving but not too lenient
wallStickFrames: 3,             // ~50ms — brief pause on contact for readability
```

### 3. Add Wall State Properties to `Player` class

```typescript
// Wall state
wallSide: -1 | 0 | 1 = 0;          // Which wall we're on: -1 left, 0 none, 1 right
wallJumpLockoutTimer: number = 0;    // Countdown timer for wall-jump input lockout
wallCoyoteTimer: number = 0;         // Timer for wall-jump coyote time
canWallCoyoteJump: boolean = false;  // Whether wall coyote jump is available
wallStickTimer: number = 0;          // Countdown for wall stick on initial contact
```

### 4. Implement WALL_SLIDING State

**Entry conditions** (checked from FALLING and JUMPING states):
- Player is not grounded
- Player is touching a wall (use `tileMap.isTouchingWall()`)
- Player is moving downward or has very low upward velocity (`velocity.y > -50`)
- Player is NOT in wall-jump lockout (`wallJumpLockoutTimer <= 0`)
- Player is holding the direction toward the wall OR was already wall-sliding

**Enter:**
- Set `wallSide` to the wall direction (-1 or 1)
- Set `wallStickTimer = wallStickFrames` (brief pause on contact)
- Zero out horizontal velocity (snap to wall)
- If moving upward, don't cut vertical velocity — let it bleed off naturally

**Update (each frame):**
- **Wall stick**: if `wallStickTimer > 0`, decrement it and hold velocity.y at 0 (brief grip on contact). This gives a tiny "latch" feel that makes wall contact readable.
- **Graduated friction**:
  - Check if player is holding toward the wall (same direction as `wallSide`). If so, use `wallSlideGripSpeed` as max slide speed. Otherwise, use `wallSlideBaseSpeed`.
  - Accelerate `velocity.y` toward the max slide speed using `wallSlideAcceleration` (NOT instant — smoothly ramps to slide speed)
  - Clamp `velocity.y` between 0 and the max slide speed (positive = downward)
- **Air control**: the player CAN input horizontal movement away from the wall. If input direction is away from wall, transition to FALLING.
- **Jump check**: if `input.isPressed(Jump)` → transition to WALL_JUMPING
- **Leave wall**: if player moves away from the wall or the wall ends (check `isTouchingWall`), transition to FALLING. Set `canWallCoyoteJump = true` and `wallCoyoteTimer = 0` (for wall coyote time).
- **Ground**: if grounded → IDLE or RUNNING

**Exit:**
- Record wall side for coyote time

**Render notes:**
- Player rectangle should lean slightly toward the wall visually — can be done with a small color shift or offset
- Different body color for wall-sliding state (e.g., teal `#2dd4bf`)

### 5. Implement WALL_JUMPING State

This is a specialized jump state with input lockout. After the lockout expires, it transitions to JUMPING or FALLING.

**Enter:**
- Set `velocity.y = -params.wallJumpVerticalSpeed` (upward)
- Set `velocity.x = params.wallJumpHorizontalSpeed * -wallSide` (away from wall). If `wallSide = 1` (right wall), kick left. If `wallSide = -1` (left wall), kick right.
- Set `wallJumpLockoutTimer = params.wallJumpLockoutFrames`
- Set `jumpHeld = true` (for variable height — can release jump early like regular jump)
- Clear `canWallCoyoteJump`
- Set `facingRight` to the direction of the kick

**Update:**
- Decrement `wallJumpLockoutTimer`
- **During lockout** (timer > 0):
  - Apply gravity (use `riseGravity` since we're going up)
  - Apex float check (same as JUMPING)
  - DO NOT apply air control — player cannot steer. This is the "punchy" lockout.
  - **Variable height**: if jump released, apply `jumpCutMultiplier` (same as regular jumping)
- **After lockout expires** (timer <= 0):
  - Transition to JUMPING (if still going up) or FALLING (if going down)
  - From this point, regular air control applies

**Design rationale for input lockout**: Without lockout, the player could wall-jump and immediately steer back into the same wall, trivializing wall-jump corridors. The lockout forces a brief commitment to the jump trajectory, making wall-jump chains feel rhythmic rather than spammy. 8 frames (~133ms) is short enough that it doesn't feel stiff.

### 6. Integrate Wall Detection into Player Update

In `Player.update()`, after `tileMap.resolveCollisions()`:

```typescript
// Track wall contact
if (this.tileMap) {
  const result = this.tileMap.resolveCollisions(this);
  this.grounded = result.grounded;

  // Wall detection for wall mechanics
  // Store the collision wall direction for state machine to read
  this.wallSide = result.wallDirection;

  // ... existing ceiling collision code ...
}

// Decrement wall-jump lockout timer
if (this.wallJumpLockoutTimer > 0) {
  this.wallJumpLockoutTimer--;
}
```

### 7. Add Wall Transitions to Existing States

**FALLING state update — add wall-slide entry:**
After air control but before landing check, add:
```typescript
// Wall-slide entry: touching wall, moving down or slow up, not locked out
if (player.wallJumpLockoutTimer <= 0 && !player.grounded) {
  if (player.tileMap) {
    const touchingRight = player.tileMap.isTouchingWall(player, 1);
    const touchingLeft = player.tileMap.isTouchingWall(player, -1);
    const hInput = getHorizontalInput(input);

    if (touchingRight && (hInput > 0 || player.velocity.y > 0) && player.velocity.y > -50) {
      player.wallSide = 1;
      player.stateMachine.setState(STATE_WALL_SLIDING);
      return;
    }
    if (touchingLeft && (hInput < 0 || player.velocity.y > 0) && player.velocity.y > -50) {
      player.wallSide = -1;
      player.stateMachine.setState(STATE_WALL_SLIDING);
      return;
    }
  }
}
```

**FALLING state — add wall coyote jump:**
Near the coyote time check, also check wall coyote:
```typescript
// Wall coyote jump
if (player.canWallCoyoteJump && player.wallCoyoteTimer <= player.params.wallJumpCoyoteFrames) {
  if (input.isPressed(InputAction.Jump)) {
    player.canWallCoyoteJump = false;
    player.stateMachine.setState(STATE_WALL_JUMPING);
    return;
  }
  player.wallCoyoteTimer++;
} else {
  player.canWallCoyoteJump = false;
}
```

**JUMPING state update — add wall-slide entry:**
Same wall-slide entry logic as FALLING, but only when the player is moving downward (don't interrupt a rising jump with wall-slide):
```typescript
if (player.velocity.y > 0) {
  // Same wall touch check as FALLING
}
```

### 8. Create Test Page `/test/wall-mechanics/page.tsx`

Replace the stub with a fully functional test page. `'use client'` component.

**Test Level Geometry:**
Design a level optimized for wall mechanics testing:

```
 ┌────────────────────────────────────────────────────────────────┐
 │                                                                │
 │   ┌──┐                                        ┌──┐            │
 │   │  │  high wall                 chimney      │  │            │
 │   │  │                           ┌──┐  ┌──┐   │  │            │
 │   │  │                           │  │  │  │   │  │            │
 │   │  │           ┌──┐            │  │  │  │   │  │            │
 │   │  │  mid plat │  │            │  │  │  │   │  │            │
 │   │  │           │  │            │  │  │  │   │  │            │
 │   │  │           │  │   ┌──┐     │  └──┘  │   │  │            │
 │   │  │           │  │   │  │     │ narrow │   │  │            │
 │   │  │           │  │   │  │     │corridor│   │  │            │
 │   │  │           │  │   │  │     │        │   │  │            │
 │   └──┘           └──┘   └──┘     └────────┘   └──┘            │
 │                                                                │
 │   ___________________    ___    _______________________________│
 │  |                   |  | P |  |                               │
 │  |    main floor     |  |   |  |        main floor             │
 │  |___________________|  |___|  |_______________________________│
 └────────────────────────────────────────────────────────────────┘
```

Specific elements:
- **Main floor**: wide base platforms, split by a pit
- **Left tall wall** (~300px height): for basic wall-slide testing. Player jumps from floor, grabs wall, slides down.
- **Mid platform pair**: two parallel walls ~80px apart for basic wall-jump chain testing
- **Right tall wall** (~300px height): mirror of left wall
- **Narrow corridor** (chimney): two parallel walls ~60px apart, tall (~250px). For vertical wall-jump climbing test — the player should be able to wall-jump up the chimney by alternating between walls.
- **Small pit**: narrow gap in the floor with walls on each side — wall-slide down, wall-jump back up
- **Ceiling**: boundary at top
- **Boundary walls**: left and right edges

All geometry within reasonable reach of the player's movement capabilities (ground jump + wall-jump should be able to reach the chimney top).

**Debug Overlays (drawn on canvas):**
- Player hitbox (cyan outline)
- Velocity vector (amber arrow)
- State label above player (purple text)
- Ground contact indicator (green dot)
- **Wall contact indicator**: colored bars on the side of the player touching the wall (magenta bars on left/right edge of hitbox)
- **Wall-slide friction indicator**: show current effective slide speed vs max (small bar)
- **Wall-jump lockout indicator**: timer bar that depletes during lockout (red bar that shrinks)
- **Wall coyote indicator**: timer bar when wall coyote time is active (orange bar)
- **Wall-jump trajectory preview**: brief ghosted arc showing predicted path (optional — nice to have)
- FPS counter
- Velocity readout (X and Y)
- Wall state diagnostics: "Wall side: L/R/None", "Lockout: N frames", "Stick: N frames", "Wall coyote: N frames"

**Debug Panel Sliders:**

All existing ground + jump params (from previous tasks, keep them accessible), PLUS wall params:

| Parameter | Min | Max | Step | Default | Description |
|-----------|-----|-----|------|---------|-------------|
| Wall Slide Base Speed | 20 | 300 | 10 | 120 | Slide speed when not holding toward wall |
| Wall Slide Grip Speed | 5 | 150 | 5 | 40 | Slide speed when holding toward wall |
| Wall Slide Acceleration | 200 | 2000 | 50 | 800 | How quickly slide speed ramps |
| Wall Jump H Speed | 100 | 500 | 10 | 260 | Horizontal kick-off speed |
| Wall Jump V Speed | 150 | 500 | 10 | 340 | Vertical boost speed |
| Wall Jump Lockout | 0 | 20 | 1 | 8 | Input lockout frames after wall-jump |
| Wall Jump Coyote | 0 | 15 | 1 | 5 | Coyote frames after leaving wall |
| Wall Stick | 0 | 10 | 1 | 3 | Brief stick frames on wall contact |

Organize sliders in collapsible sections: "Ground Movement", "Jumping", "Wall Mechanics".

Also include:
- "Reset Player" button (respawn at start position)
- "Reset Params" button (reset ALL params to defaults)
- Debug overlay toggle

**Pass Criteria** (display on the test page):
1. Player slides down walls at a controlled speed (not free-fall)
2. Holding toward the wall makes the slide slower (grip), releasing makes it faster
3. Wall-slide stops when reaching the ground (transition to ground state)
4. Wall-jump launches player away from wall at a fixed angle
5. Brief input lockout prevents immediately re-sticking to the same wall
6. After lockout, normal air control resumes
7. Player can chain wall-jumps between two parallel walls to climb upward
8. Can wall-jump up a narrow chimney corridor rhythmically
9. Wall coyote time: can jump briefly after leaving a wall
10. Wall-slide does not trigger when player is jumping upward past a wall
11. All wall parameters are tunable via sliders in real time
12. Existing ground movement and jumping still work correctly

## Files to Create

- `src/app/test/wall-mechanics/page.tsx` — Full test page (replaces stub)

## Files to Modify

- `src/engine/physics/TileMap.ts` — Add `wallDirection` to `CollisionResult`, add `isTouchingWall()` method
- `src/engine/entities/Player.ts` — Add wall params, wall state properties, WALL_SLIDING state, WALL_JUMPING state, wall transitions in FALLING/JUMPING
- `src/lib/testStatus.ts` — Update wall-mechanics status to `'in-progress'`

## Implementation Notes

### Wall-slide "graduated friction" explained

The graduated friction system works as follows:
- The wall acts as a vertical surface the player slides along
- `wallSlideBaseSpeed` is the max downward speed when just touching the wall (no input toward wall). Think of it as "resting on the wall"
- `wallSlideGripSpeed` is the max downward speed when actively holding toward the wall. It's slower (more grip), creating the "hold to grab tighter" feel
- `wallSlideAcceleration` controls how quickly `velocity.y` approaches the max slide speed. It should be fast enough that the player doesn't free-fall for a noticeable moment before the wall slide kicks in
- When the player first contacts the wall, `wallStickFrames` creates a brief pause (velocity.y = 0) that makes the contact feel deliberate and readable

The effective behavior:
1. Touch wall → brief stick (3 frames ≈ 50ms pause)
2. Release stick → begin sliding at base speed (120 px/s) — slow, controlled
3. Hold toward wall → slide speed reduces to grip speed (40 px/s) — very slow, gripping
4. Release input → slide speed increases back to base speed
5. Hold away from wall → detach, enter FALLING

### Wall-jump "fixed launch angle" explained

The wall-jump always launches at the same angle regardless of player input. This is important because:
- It creates predictable, rhythmic wall-jump chains
- The player can't aim the wall-jump — they commit to it
- The input lockout prevents immediately overriding the trajectory
- After lockout, they regain control and can steer

The "angle" is defined by two speeds: `wallJumpHorizontalSpeed` (260) and `wallJumpVerticalSpeed` (340). This gives roughly a 52° angle from horizontal — steep enough to gain height, wide enough to clear to the opposite wall in a corridor.

### Don't break existing features

Wall mechanics are additive. Verify:
- Ground movement (run, crouch, slide) works exactly as before
- Regular jumping (variable height, coyote time, input buffer, apex float) works
- The only changes to FALLING and JUMPING states are adding wall transition checks
- No changes to IDLE, RUNNING, CROUCHING, CROUCH_SLIDING states

### State constant naming

Add to the existing state constants in Player.ts:
```typescript
const STATE_WALL_SLIDING = "WALL_SLIDING";
const STATE_WALL_JUMPING = "WALL_JUMPING";
```

### Camera

The test level may be slightly larger than the viewport. Use the Engine's camera system — have it follow the player with smooth tracking. The camera is already implemented; just set `camera.position` to center on the player each frame in the test page's update callback.

### Wall detection edge case: corners

When the player is at the corner where a wall meets the floor, they should land on the floor, not wall-slide. The Y-then-X collision resolution order already handles this (grounded is resolved first). The wall-slide entry condition also checks `!player.grounded`, which prevents this.

### Wall detection edge case: thin walls

If a wall is thinner than the player, the player might pass through. This is okay for now — design test level walls to be thick enough (at least 32px wide).

## Design Decisions (Pre-settled)

1. **Two states for wall mechanics**: WALL_SLIDING and WALL_JUMPING are separate states. WALL_JUMPING has the lockout timer, then transitions to regular JUMPING/FALLING.
2. **Input lockout in WALL_JUMPING**: Player cannot steer during lockout. This is the "punchy" feel — the jump commits you to a trajectory briefly.
3. **Graduated friction via speed clamping**: Not literally a friction force — instead, clamp slide velocity to different max speeds based on input. This is simpler and more tunable.
4. **Wall stick is brief and cosmetic**: 3 frames of zero vertical velocity on first wall contact. Just enough to make the contact feel deliberate.
5. **Wall coyote time**: Separate from ground coyote time. 5 frames after leaving a wall, the player can still wall-jump. Uses a separate `canWallCoyoteJump` flag.
6. **No wall-slide from jumping upward**: Only enter wall-slide if `velocity.y > -50`. If the player is jumping upward past a wall, they shouldn't stick to it.
7. **Wall-jump variable height**: Uses the same `jumpCutMultiplier` system as regular jumping. Releasing jump early during a wall-jump cuts the arc.
8. **CollisionResult.wallDirection**: Enhanced to report side, but the code stays backward-compatible — `hitWall` boolean still works.

## Verification

- [ ] `npx tsc --noEmit` passes with zero errors
- [ ] `npm run build` succeeds
- [ ] Navigate to `/test/wall-mechanics` — canvas renders with test level and player
- [ ] Player can jump to a wall and slide down it
- [ ] Holding toward the wall slows the slide (grip)
- [ ] Releasing direction input increases slide speed (base speed)
- [ ] Brief stick on wall contact is perceptible
- [ ] Wall-jump launches at fixed angle away from wall
- [ ] Input lockout prevents steering during the first ~133ms of wall-jump
- [ ] After lockout, normal air control resumes
- [ ] Can chain wall-jumps between parallel walls to climb
- [ ] Can wall-jump up the chimney corridor
- [ ] Wall coyote time works (can jump shortly after leaving wall)
- [ ] Wall-slide does NOT trigger when jumping upward past a wall
- [ ] Landing on ground from wall-slide transitions to ground state
- [ ] Ground movement and regular jumping still work perfectly
- [ ] All sliders update physics in real time
- [ ] Debug overlays show wall contact, lockout timer, coyote timer
- [ ] FPS stays at ~60fps
- [ ] Reset buttons work

---

## Implementation Summary

### Files Modified
- **`src/engine/physics/TileMap.ts`** — Added `wallDirection: -1 | 0 | 1` to `CollisionResult` interface; added `isTouchingWall()` method using a 1px probe rect for wall adjacency detection
- **`src/engine/entities/Player.ts`** — Added 8 wall mechanic params to `PlayerParams` and `DEFAULT_PLAYER_PARAMS`; added 5 wall state properties; implemented `STATE_WALL_SLIDING` (graduated friction, wall stick, detach/jump transitions) and `STATE_WALL_JUMPING` (fixed-angle launch, input lockout, variable height); added wall-slide entry checks to FALLING and JUMPING states; added wall coyote jump to FALLING state; added lockout timer decrement to `update()`; added teal/violet body colors for wall states
- **`src/lib/testStatus.ts`** — Updated wall-mechanics status to `'in-progress'`

### Files Created
- **`src/app/test/wall-mechanics/page.tsx`** — Full test page with: custom wall-testing level (left wall, mid pair, narrow chimney, right wall, pit with walls); camera following player; all debug overlays (hitbox, velocity vector, state label, ground contact, wall contact bars, friction indicator, lockout bar, wall coyote bar, apex float glow); screen-space diagnostics (FPS, velocity, wall side, lockout, stick, coyote timers); collapsible slider sections for Ground Movement, Jumping, Wall Mechanics; reset player/params buttons; debug overlay toggle

### Key Design Decisions
- Wall-slide uses `currentGravity = 0` and controls `velocity.y` directly for precise slide speed control
- `isTouchingWall` probe is inset by 1px top/bottom to avoid false positives at floor/ceiling corners
- Wall-jump lockout timer decremented in `Player.update()` (not in state update) so it counts down even across state transitions
- Chimney corridor gap is 60px (between 32px walls at x=560 and x=652) — wide enough for the 24px player with room for wall-jump trajectory

---

## Review (c41b8af8)

### Issues Found and Fixed

1. **Bug: JUMPING.enter reset velocity when entered from WALL_JUMPING** (`Player.ts:368-376`)
   - `STATE_JUMPING.enter` unconditionally set `velocity.y = -jumpSpeed`, which would override the wall-jump trajectory when WALL_JUMPING transitioned to JUMPING after lockout expired. This effectively gave the player a free second full-height jump.
   - **Fix:** Added a guard `if (prev !== STATE_WALL_JUMPING)` so that entering JUMPING from WALL_JUMPING preserves the existing velocity, jumpHeld, and coyote state.

2. **Bug: WALL_SLIDING used hardcoded `1/60` instead of `dt` parameter** (`Player.ts:581,641-646`)
   - The state update signature had `_dt` (unused), and the acceleration calculation used `const dt60 = 1 / 60`. While the engine does run at a fixed 1/60 timestep, this is fragile and bad practice — if the timestep constant changes, wall-slide physics would break.
   - **Fix:** Changed `_dt` to `dt` and replaced `dt60` with `dt` in the acceleration calculations.

3. **Bug: Upward velocity clamp in WALL_SLIDING contradicted design intent** (`Player.ts:649-651`)
   - A clamp `if (velocity.y < 0) velocity.y = 0` immediately zeroed any upward velocity, contradicting the `enter` handler's comment "Don't cut upward velocity — let it bleed off naturally". The acceleration code already handles ramping toward the target slide speed.
   - **Fix:** Removed the redundant clamp. The acceleration code naturally bleeds off upward velocity over a few frames.

### No Issues Found In

- **TileMap.ts** — `wallDirection` and `isTouchingWall()` are correctly implemented. Probe inset of 1px top/bottom properly avoids corner false positives.
- **Test page** (`wall-mechanics/page.tsx`) — Well structured. All 8 wall params wired to sliders. Debug overlays comprehensive. Engine cleanup on unmount via `handleUnmount`. Camera smoothing implemented. Auto-respawn works. No memory leaks spotted.
- **testStatus.ts** — Correctly updated to `'in-progress'`.

### Verification

- `npx tsc --noEmit` passes with zero errors
- `npm run build` succeeds
