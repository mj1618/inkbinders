# Task: Dash — 8-Directional Dash, I-Frames, Dash-Cancel, Speed Boost, Cooldown

## What to Build

Implement the dash system for the player character and create a fully functional test page at `/test/dash` with debug overlays and tunable sliders.

After this task, the player should be able to:
- Dash in 8 directions (or neutral dash = forward) from nearly any state
- Experience a 1–2 frame wind-up, then a fixed-distance burst with i-frames
- Dash-cancel out of most states (idle, running, jumping, falling, wall-sliding, crouching, crouch-sliding)
- Preserve speed into a run after a ground dash when holding forward
- Chain dashes only after a short cooldown (timing > spamming)
- NOT dash during wall-jump lockout or while already dashing

**This task builds on the existing Player entity (8 states: IDLE, RUNNING, CROUCHING, CROUCH_SLIDING, JUMPING, FALLING, WALL_SLIDING, WALL_JUMPING). It adds the DASHING state.**

## Prerequisites

The existing codebase has:
- `InputManager` with `InputAction.Dash` already defined but unused
- `InputManager` with `isPressed()`, `isHeld()`, `consumeBufferedInput()`
- `StateMachine` with enter/update/exit lifecycle and `timeInState`
- Player with 8 working states and all ground/jump/wall mechanics
- `TileMap` with collision resolution and `isTouchingWall()`
- Fixed-timestep game loop at 60 Hz (`FIXED_TIMESTEP = 1/60`)

## Changes Needed

### 1. Add Dash Parameters to `PlayerParams` in `src/engine/entities/Player.ts`

Add these fields to the `PlayerParams` interface:

```typescript
// Dash parameters
dashSpeed: number;            // Movement speed during dash (px/s)
dashDurationFrames: number;   // How many frames the dash lasts (at 60Hz)
dashWindupFrames: number;     // Wind-up freeze frames before dash starts
dashCooldownFrames: number;   // Cooldown frames after dash ends before next dash allowed
dashSpeedBoost: number;       // Speed multiplier applied to run speed after ground dash when holding forward
dashSpeedBoostDecayRate: number; // How quickly the speed boost decays (px/s²)
```

Add these defaults to `DEFAULT_PLAYER_PARAMS`:

```typescript
dashSpeed: 600,               // Fast but not teleport — covers ~150px in 15 frames
dashDurationFrames: 15,       // 250ms at 60Hz — long enough to feel impactful, short enough to not lose control
dashWindupFrames: 1,          // ~17ms — barely perceptible windup that makes the burst feel punchier
dashCooldownFrames: 18,       // 300ms cooldown — encourages timing over spamming
dashSpeedBoost: 1.4,          // 40% speed boost into run after ground dash
dashSpeedBoostDecayRate: 800, // Decays relatively quickly — a burst of speed, not a permanent buff
```

### 2. Add Dash State Properties to `Player` class

```typescript
// Dash state
dashDirection: { x: number; y: number } = { x: 0, y: 0 }; // Normalized dash direction vector
dashTimer: number = 0;         // Counts frames during dash
dashWindupTimer: number = 0;   // Counts wind-up frames
dashCooldownTimer: number = 0; // Counts cooldown frames after dash
dashAvailable: boolean = true; // Whether dash is off cooldown
isDashing: boolean = false;    // True during the active dash (for i-frame checks)
isInDashWindup: boolean = false; // True during wind-up
dashSpeedBoostRemaining: number = 0; // Current speed boost factor (decays over time)
dashWasGrounded: boolean = false; // Whether the dash started on the ground (for speed boost logic)
```

### 3. Add `STATE_DASHING` constant

```typescript
const STATE_DASHING = "DASHING";
```

### 4. Implement DASHING State

**Dash direction resolution:**

When dash is initiated, determine direction from held inputs:
- If horizontal and/or vertical input is held → dash in that direction (8-directional: cardinal + diagonal)
- If NO directional input is held → dash in facing direction (forward)
- Normalize the direction vector so diagonal dashes cover the same distance as cardinal dashes

```typescript
function getDashDirection(input: InputManager, facingRight: boolean): { x: number; y: number } {
  let dx = 0;
  let dy = 0;

  if (input.isHeld(InputAction.Left)) dx -= 1;
  if (input.isHeld(InputAction.Right)) dx += 1;
  if (input.isHeld(InputAction.Up)) dy -= 1;
  if (input.isHeld(InputAction.Down)) dy += 1;

  // If no direction held, dash in facing direction
  if (dx === 0 && dy === 0) {
    dx = facingRight ? 1 : -1;
  }

  // Normalize for diagonal dashes
  const mag = Math.sqrt(dx * dx + dy * dy);
  if (mag > 0) {
    dx /= mag;
    dy /= mag;
  }

  return { x: dx, y: dy };
}
```

**Enter:**
- Resolve dash direction from current input + facing
- Store `dashDirection`
- Set `dashWindupTimer = params.dashWindupFrames`
- Set `isInDashWindup = true`
- Set `isDashing = false` (not yet — wind-up first)
- Store `dashWasGrounded = player.grounded`
- Zero velocity (brief freeze during wind-up)
- Set `dashAvailable = false`
- If dashing from CROUCHING or CROUCH_SLIDING, uncrouch first (restore full hitbox height if possible; if can't uncrouch due to ceiling, dash crouched — keep crouched height and only allow horizontal dash)

**Update (each frame):**

Phase 1 — Wind-up:
- If `dashWindupTimer > 0`: decrement timer, keep velocity at zero, player does not move. This is the "anticipation" frame that makes the burst feel punchier.
- When `dashWindupTimer` reaches 0, transition to active dash: set `isDashing = true`, `isInDashWindup = false`, `dashTimer = params.dashDurationFrames`

Phase 2 — Active dash:
- Set `velocity.x = dashDirection.x * params.dashSpeed`
- Set `velocity.y = dashDirection.y * params.dashSpeed`
- Set `currentGravity = 0` (no gravity during dash — even in air)
- Decrement `dashTimer`
- Collision resolution still runs — if the player dashes into a wall, they stop against it. The dash ends early if the player hits a wall in the dash direction.
- When `dashTimer` reaches 0 → dash ends, transition out

**Exit:**
- Set `isDashing = false`
- Set `isInDashWindup = false`
- Set `dashCooldownTimer = params.dashCooldownFrames`
- Determine exit state:
  - If player is grounded:
    - If holding horizontal input in dash direction → transition to RUNNING. Apply `dashSpeedBoostRemaining = params.dashSpeedBoost` (this is a multiplier on maxRunSpeed that decays)
    - If not holding input → transition to IDLE with brief slide (velocity bleeds off via deceleration)
  - If player is in the air:
    - Preserve some horizontal momentum: `velocity.x = dashDirection.x * params.maxRunSpeed` (don't keep full dash speed, but don't kill momentum either)
    - If `velocity.y >= 0` → FALLING
    - If `velocity.y < 0` → JUMPING (preserve upward momentum)
  - If player is touching a wall (after an air dash into a wall):
    - If holding into wall and moving down → WALL_SLIDING
    - Otherwise → FALLING

**Collision during dash:**
- If the player dashes horizontally into a wall: velocity.x is zeroed by collision resolution, effectively ending forward momentum. The dash timer still counts down, but the player is stuck against the wall. This is fine — it's the "bonk" case.
- If the player dashes downward into the floor: similarly, velocity.y zeroed, player lands. Transition to appropriate ground state.
- No special handling needed — the existing collision system handles this naturally.

### 5. Add Dash-Cancel to Existing States

The dash-cancel check should be added to the UPDATE function of each state that allows dashing. It should be checked EARLY in the update (before other input checks) so that dash takes priority.

**Helper function:**

```typescript
function tryDash(player: Player, input: InputManager): boolean {
  if (!player.dashAvailable) return false;
  if (player.dashCooldownTimer > 0) return false;
  if (!input.isPressed(InputAction.Dash)) return false;

  player.stateMachine.setState(STATE_DASHING);
  return true;
}
```

**States that allow dash-cancel:**
- IDLE — yes (neutral dash → forward)
- RUNNING — yes (directional dash)
- CROUCHING — yes (directional dash, uncrouches)
- CROUCH_SLIDING — yes (directional dash, uncrouches)
- JUMPING — yes (air dash)
- FALLING — yes (air dash)
- WALL_SLIDING — yes (directional dash, often used to dash away from wall)

**States that do NOT allow dash-cancel:**
- WALL_JUMPING — no (already committed to wall-jump trajectory during lockout; after lockout the state transitions to JUMPING/FALLING which DO allow dash)
- DASHING — no (can't dash during a dash)

Add `if (tryDash(player, input)) return;` near the top of each allowed state's update function.

### 6. Dash Cooldown Timer Management

In `Player.update()` (the main update function, outside state machine), add:

```typescript
// Dash cooldown
if (this.dashCooldownTimer > 0) {
  this.dashCooldownTimer--;
  if (this.dashCooldownTimer <= 0) {
    this.dashAvailable = true;
  }
}
```

### 7. Dash Speed Boost in RUNNING State

When the player exits a ground dash into RUNNING, they get a temporary speed boost. Modify the RUNNING state update:

```typescript
// In RUNNING update:
let effectiveMaxSpeed = params.maxRunSpeed;

// Apply dash speed boost if active
if (player.dashSpeedBoostRemaining > 1.0) {
  effectiveMaxSpeed = params.maxRunSpeed * player.dashSpeedBoostRemaining;
  // Decay the boost
  player.dashSpeedBoostRemaining -= params.dashSpeedBoostDecayRate * dt / params.maxRunSpeed;
  if (player.dashSpeedBoostRemaining < 1.0) {
    player.dashSpeedBoostRemaining = 0;
  }
}

// Use effectiveMaxSpeed instead of params.maxRunSpeed for speed clamping
```

The speed boost is a multiplier (e.g. 1.4 = 40% faster) that decays over time. When the player stops holding forward or changes direction, the boost immediately ends.

### 8. Dash Recharge on Landing

The dash should recharge when the player lands on the ground (not just by cooldown). This creates the Celeste-like feel where air-dashing is a precious resource:

- In IDLE and RUNNING state `enter`: if `dashCooldownTimer <= 0`, set `dashAvailable = true`
- In FALLING → ground transition: same
- The cooldown timer still applies — you can't spam dash even on the ground

This means: one air dash per jump (recharged on landing), but ground dashes are limited only by cooldown.

Wait — actually, let's keep it simpler for now. **Dash recharges purely by cooldown timer, regardless of grounded/air.** The plan says "short cooldown: timing > spamming", which implies a timer-based recharge. We can add air-dash-limit mechanics later if needed for balance. For this task, the dash simply becomes available again once the cooldown timer expires.

### 9. Create Test Page `/test/dash/page.tsx`

Replace the stub with a fully functional test page. `'use client'` component.

**Test Level Geometry:**

Design a level that tests all dash scenarios:

```
 ┌────────────────────────────────────────────────────────────────┐
 │                                                                │
 │        ┌──────────────────────────────────────────────┐        │
 │        │              ceiling for down-dash test      │        │
 │        └──────────────────────────────────────────────┘        │
 │                                                                │
 │                                                                │
 │  ┌──┐                                              ┌──┐       │
 │  │  │  high wall for                    high wall   │  │       │
 │  │  │  wall-dash combo                  for wall    │  │       │
 │  │  │                                   dash combo  │  │       │
 │  │  │           ┌──────────┐                        │  │       │
 │  │  │           │ floating │                        │  │       │
 │  │  │           │ platform │                        │  │       │
 │  │  │           └──────────┘                        │  │       │
 │  │  │                                               │  │       │
 │  │  │    ┌───┐          ┌─────┐     ┌───┐           │  │       │
 │  │  │    │low│          │ gap │     │low│           │  │       │
 │  │  │    │   │          │ too │     │   │           │  │       │
 │  └──┘    └───┘          │ far │     └───┘           └──┘       │
 │                         │ to  │                                │
 │  ___________  ____      │jump │     ________  _________________│
 │ |           ||    |     │     │    |        ||                 │
 │ |  floor A  || B  |     └─────┘    | floor C||    floor D      │
 │ |___________||____|                |________||_________________│
 │                    ↑ gap (requires dash to cross) ↑            │
 └────────────────────────────────────────────────────────────────┘
```

Specific elements:
- **Floor A**: Main platform, wide (~250px), for basic ground dash testing
- **Floor B**: Short platform for ground-to-air dash testing
- **Dash gap**: A gap between B and C that's too far to jump (~200px) — requires a dash to cross. This is the key test: can the player jump and then dash across?
- **Floor C**: Landing platform after the gap
- **Floor D**: Wide platform continuing right
- **Left/Right tall walls** (~250px height): For wall-dash combo testing (wall-slide then dash away)
- **Floating platform**: Above the center, reachable by jump + upward dash. Tests vertical dash.
- **Low obstacles**: Small blocks that the player can dash through horizontally (test dash distance)
- **Ceiling section**: A low ceiling area to test downward dash into ground and dash under tight spaces (crouch-dash)
- **Boundary walls**: left and right edges, floor and ceiling

All geometry should be positioned so that the dash distance (~150px at default speed/duration) is meaningful — gaps are sized to require dashing, platforms are reachable with dash combos.

**Debug Overlays (drawn on canvas):**
- Player hitbox (cyan outline)
- Velocity vector (amber arrow)
- State label above player (purple text)
- Ground contact indicator (green dot)
- **Dash direction indicator**: When dashing, draw an arrow in the dash direction (bright magenta)
- **Dash trail/ghost**: Semi-transparent rectangles at the player's previous positions during dash (creates a speed-line effect). Render the last 5–8 positions as fading ghosts.
- **I-frame indicator**: Flash the player hitbox outline white during i-frames
- **Dash cooldown indicator**: Small bar below player that fills up as cooldown expires (gray → green when available)
- **Wind-up indicator**: Brief flash/freeze frame indicator during wind-up
- **Dash distance marker**: At the start of a dash, draw a thin line to the projected end position (helps visualize dash range)
- FPS counter
- Velocity readout (X and Y)
- Dash diagnostics: "Dash: AVAILABLE/COOLDOWN", "Cooldown: N frames", "Speed boost: Nx", "Dash dir: (x, y)"
- Wall contact indicators (from previous implementation)

**Debug Panel Sliders:**

All existing ground + jump + wall params (from previous tasks, keep them accessible), PLUS dash params:

| Parameter | Min | Max | Step | Default | Description |
|-----------|-----|-----|------|---------|-------------|
| Dash Speed | 200 | 1200 | 25 | 600 | Movement speed during dash |
| Dash Duration | 5 | 30 | 1 | 15 | Frames of active dash |
| Dash Windup | 0 | 5 | 1 | 1 | Wind-up freeze frames before dash |
| Dash Cooldown | 0 | 60 | 1 | 18 | Cooldown frames after dash |
| Dash Speed Boost | 1.0 | 2.5 | 0.05 | 1.4 | Run speed multiplier after ground dash |
| Dash Boost Decay | 200 | 2000 | 50 | 800 | How quickly boost decays (px/s²) |

Organize sliders in collapsible sections: "Ground Movement", "Jumping", "Wall Mechanics", "Dash".

Also include:
- "Reset Player" button (respawn at start position)
- "Reset Params" button (reset ALL params to defaults)
- Debug overlay toggle

**Pass Criteria** (display on the test page):
1. Player can dash in 8 directions (4 cardinal + 4 diagonal) plus neutral (forward) dash
2. Dash has a brief wind-up freeze frame before the burst
3. Dash covers a fixed distance regardless of starting velocity
4. Player cannot be affected by gravity during dash
5. Dash-cancel works from: idle, running, jumping, falling, wall-sliding, crouching, crouch-sliding
6. Cannot dash during: wall-jump lockout, another dash, cooldown
7. Ground dash into run preserves speed boost when holding forward
8. Speed boost decays smoothly back to normal run speed
9. Dash cooldown timer prevents spamming — must wait between dashes
10. Air dash preserves horizontal momentum into the exit state
11. Dashing into a wall stops the player (no clipping through)
12. Dashing downward into the floor lands the player
13. Dash trail/ghost effect is visible during dash
14. All dash parameters are tunable via sliders in real time
15. Existing ground movement, jumping, and wall mechanics still work correctly

## Files to Create

- `src/app/test/dash/page.tsx` — Full test page (replaces stub)

## Files to Modify

- `src/engine/entities/Player.ts` — Add dash params, dash state properties, DASHING state, dash-cancel in existing states, dash cooldown management, speed boost in RUNNING
- `src/lib/testStatus.ts` — Update dash status to `'in-progress'`

## Implementation Notes

### Dash "fixed distance" explained

The dash should feel like it covers a consistent distance. With `dashSpeed = 600` and `dashDurationFrames = 15`, the dash covers `600 * (15/60) = 150px` in ideal conditions. This is about 6.25 player widths — enough to cross a meaningful gap, short enough to require precision.

If the player hits a wall during the dash, the dash still ends after the timer runs out (they just don't cover the full distance). No special early-exit needed — collision resolution naturally handles this.

### I-frames explained

The `isDashing` flag is set to `true` during the active dash phase (not during wind-up). This flag can be checked later by the combat system to skip damage application. For now, just set the flag and visualize it — the combat system will use it when it exists.

### Wind-up "freeze frame" explained

The 1-frame wind-up is a design technique from Celeste/Hollow Knight. It creates a tiny pause before the burst that makes the dash feel more impactful. During wind-up:
- Player velocity is zeroed
- Player is visually frozen
- A brief visual indicator (screen shake, color flash) can signal the dash is about to fire
- After wind-up, the full dash speed kicks in instantly

At 1 frame (~17ms), it's barely perceptible but adds a lot of tactile feel. The slider lets you tune from 0 (instant) to 5 frames to find the sweet spot.

### Speed boost decay explained

After a ground dash, if the player is holding forward, they enter RUNNING with `dashSpeedBoostRemaining = 1.4` (40% speed boost). The effective max run speed is `maxRunSpeed * dashSpeedBoostRemaining`.

Each frame, the boost decays: `dashSpeedBoostRemaining -= dashSpeedBoostDecayRate * dt / maxRunSpeed`. With default values, the boost decays from 1.4 to 1.0 over roughly 0.14 seconds (~8 frames). This creates a brief surge of speed that bleeds off smoothly, rewarding players who dash and immediately continue running.

If the player stops holding forward, reverses direction, or enters any non-running state, `dashSpeedBoostRemaining` is immediately zeroed.

### Dash from wall-slide

When the player dashes from a wall-slide, they can aim in any direction (not just away from the wall). This is powerful and intentional — wall-dash combos are an advanced movement technique. The dash direction is determined by held inputs at the moment dash is pressed, same as any other dash.

### Dash-cancel priority

In each state's update function, the dash check should come AFTER the state's own critical checks but BEFORE movement input processing. For example, in RUNNING:

```
1. Check grounded (if not grounded, transition to FALLING)
2. Check dash input ← dash-cancel here
3. Check jump input
4. Process horizontal movement
```

This order ensures:
- Falling always takes priority over dash (can't dash from thin air right after losing ground — must first enter FALLING, then dash from FALLING)
- Dash takes priority over jump and movement
- Jump takes priority over movement

### Don't break existing features

Dash is additive. The ONLY changes to existing states are adding `tryDash()` calls. Verify:
- Ground movement (run, crouch, slide) works exactly as before
- Jumping (variable height, coyote time, input buffer, apex float) works
- Wall mechanics (slide, jump, coyote) work
- No changes to the collision system
- No changes to the TileMap

### Player rendering during dash

The player body color during DASHING should be distinct:
- Wind-up phase: bright white `#ffffff` (flash before the burst)
- Active dash: hot pink/magenta `#f472b6`
- The ghost trail uses the same color at 30% opacity, fading to 10%

### Dash ghost trail implementation

Store the last 8 positions during the dash in a ring buffer on the Player:

```typescript
dashTrailPositions: Array<{ x: number; y: number }> = [];
```

Each frame during active dash, push the current position. When rendering, draw semi-transparent rectangles at each trail position with decreasing opacity (oldest = most transparent). Clear the trail when dash ends (or let it fade out over 3–4 frames after the dash).

### Camera during dash

The camera should follow the player during dash without any special behavior — the existing smooth-follow camera is sufficient. The dash is fast enough that the camera will lag slightly behind, which actually looks good (creates a sense of speed).

## Design Decisions (Pre-settled)

1. **One state for dash**: DASHING covers both wind-up and active phases via internal timers. Simpler than two states.
2. **8-directional + neutral**: Direction is sampled at the moment of dash input. Neutral (no input) = forward.
3. **Fixed distance, not fixed time**: The "distance" is speed × duration. Both are tunable, so the designer can control the exact range.
4. **Gravity disabled during dash**: The dash moves in a straight line in its direction. No gravity pull, no air friction. This makes vertical and diagonal dashes feel clean.
5. **Cooldown-only recharge**: No air-dash limit for now. Dash recharges by timer. Can add ground-recharge later if balance needs it.
6. **Speed boost is multiplicative on maxRunSpeed**: Not an additive flat value. This means it scales with the run speed slider.
7. **Dash from crouch uncrouches**: Dashing while crouched restores full hitbox height (if possible). If can't uncrouch (ceiling), dash stays crouched and only horizontal.
8. **No dash during wall-jump lockout**: The player is already committed to the wall-jump trajectory. Allowing dash-cancel during lockout would trivialize wall-jump corridors.
9. **Collision during dash is normal**: No phasing through walls. The existing AABB collision system handles dash movement just like any other velocity.
10. **I-frames are a flag only**: No actual invulnerability system yet (no combat). The flag exists for future combat integration.

## Verification

- [ ] `npx tsc --noEmit` passes with zero errors
- [ ] `npm run build` succeeds
- [ ] Navigate to `/test/dash` — canvas renders with test level and player
- [ ] Player can dash forward (no direction input) in the facing direction
- [ ] Player can dash in all 8 directions using held inputs
- [ ] Diagonal dashes cover the same distance as cardinal dashes
- [ ] Wind-up frame is visible as a brief freeze before dash burst
- [ ] Player moves at dash speed during active dash
- [ ] No gravity during dash (horizontal dash is perfectly horizontal)
- [ ] Dash trail/ghost effect visible during dash
- [ ] Dash cooldown prevents immediate re-dash — must wait ~300ms
- [ ] Dash cooldown indicator shows remaining cooldown
- [ ] Ground dash + hold forward = brief speed boost in RUNNING
- [ ] Speed boost decays smoothly back to normal
- [ ] Air dash preserves momentum into FALLING/JUMPING
- [ ] Can dash-cancel from: IDLE, RUNNING, CROUCHING, CROUCH_SLIDING, JUMPING, FALLING, WALL_SLIDING
- [ ] Cannot dash during: WALL_JUMPING lockout, DASHING, cooldown active
- [ ] Dashing into a wall stops the player (no clipping)
- [ ] Dashing downward into floor → lands normally
- [ ] Can cross the dash gap by jumping then dashing
- [ ] Can reach the floating platform with jump + upward dash
- [ ] All sliders update physics in real time
- [ ] Debug overlays show dash direction, trail, cooldown, speed boost
- [ ] FPS stays at ~60fps
- [ ] Reset buttons work
- [ ] Existing ground movement, jumping, and wall mechanics unaffected

---

## Implementation Summary

### Files Modified

1. **`src/engine/entities/Player.ts`** — Core dash implementation
   - Added 6 dash parameters to `PlayerParams` interface and `DEFAULT_PLAYER_PARAMS`
   - Added `STATE_DASHING` constant
   - Added 11 dash state properties to Player class (dashDirection, dashTimer, dashWindupTimer, dashCooldownTimer, dashAvailable, isDashing, isInDashWindup, dashSpeedBoostRemaining, dashWasGrounded, dashTrailPositions, dashTrailFadeTimer)
   - Added `tryDash()` method (mirrors tryJump pattern)
   - Implemented full DASHING state with wind-up phase and active dash phase
   - Added `exitDash()` helper for state transitions based on grounded/air/wall context
   - Added dash-cancel (`tryDash()`) to 7 existing states: IDLE, RUNNING, CROUCHING, CROUCH_SLIDING, JUMPING, FALLING, WALL_SLIDING (including during wall-stick)
   - Wall-jumping does NOT allow dash (as specified)
   - Added dash cooldown timer management in Player.update()
   - Added dash trail fade timer management in Player.update()
   - Added dash speed boost logic in RUNNING state (multiplicative, with smooth decay and direction-change kill)
   - Updated render() with dash trail (ghost positions with fading opacity) and dash-specific body colors (white for wind-up, hot pink for active)
   - Fixed FALLING enter to exclude DASHING from coyote jump eligibility
   - Restructured ground state priorities: grounded check → dash → jump → movement (per spec)

2. **`src/app/test/dash/page.tsx`** — Full test page (replaced stub)
   - Test level with Floor A/B/C/D, 200px dash gap, tall walls, floating platform, low obstacles, ceiling section
   - Debug overlays: hitbox (white flash during i-frames), velocity vector, dash direction arrow, dash distance marker, state label, ground/wall contact, dash cooldown bar, speed boost bar, coyote indicator, apex float indicator, wind-up flash
   - Screen-space debug panel with FPS, velocity, and full dash diagnostics (status, cooldown, speed boost, direction, i-frames, windup)
   - Collapsible slider sections: Ground Movement, Jumping, Wall Mechanics, Dash (open by default)
   - All 6 dash sliders with specified min/max/step/default ranges
   - Reset Player, Reset Params, Debug Overlay toggle buttons

3. **`src/lib/testStatus.ts`** — Updated dash status to `'in-progress'`

### What Was Built

- 8-directional dash (4 cardinal + 4 diagonal + neutral forward)
- 1-frame wind-up freeze before burst (tunable 0-5)
- Fixed-distance dash at 600px/s for 15 frames (150px, both tunable)
- Zero gravity during dash
- Dash-cancel from all specified states
- Dash blocked during wall-jump lockout and active dashing
- Cooldown-based recharge (18 frames default)
- Ground dash → run speed boost (1.4x, decays at 800px/s²)
- Ghost trail with fading opacity (persists 4 frames after dash ends)
- I-frame flag set during active dash
- Crouch-dash support (uncrouches if possible, horizontal-only if ceiling-blocked)

### Verification

- `npx tsc --noEmit` passes with zero errors
- `npm run build` succeeds
- All existing states and mechanics preserved (additive changes only)

---

## Review (efd62078)

### Issues Found & Fixed

1. **Wind-up transition wasted a frame (Player.ts:870-884)** — When `dashWindupTimer` decremented to 0, the code returned early before executing Phase 2 (active dash). This meant the first frame after wind-up had zero velocity, effectively making the dash 1 frame shorter than configured and creating a 2-frame delay (wind-up + dead frame) instead of the intended 1-frame wind-up. Fixed by only returning early when `dashWindupTimer` is still > 0 after decrement, falling through to Phase 2 on the transition frame.

2. **Non-normalized dash direction after ceiling-blocked crouch dash (Player.ts:844-853)** — When dashing from a crouched position under a low ceiling, the code zeroed `dashDirection.y` but didn't re-normalize the vector. A diagonal input like (0.707, -0.707) would become (0.707, 0), giving only ~70% dash speed horizontally. Added re-normalization after zeroing y.

3. **Division-by-zero guard in speed boost indicator (dash/page.tsx:308)** — The boost bar ratio calculation divided by `dashSpeedBoost - 1.0`. If the slider is set to exactly 1.0, this would divide by zero. While the `> 1.0` guard on `dashSpeedBoostRemaining` makes this unlikely to trigger in practice, added a safety check since slider values can change mid-dash.

### Verified Clean

- `npx tsc --noEmit` — zero errors after fixes
- `npm run build` — succeeds
- All three fixes are minimal and targeted; no structural changes
- State machine transitions: all paths reviewed, no stuck states found
- Frame-rate independence: all timers are frame-count based (decremented once per fixed tick), not wall-clock based — correct
- Memory: dash trail positions array is bounded (max 8) and cleared on fade — no leak
- Input handling: dash uses `isPressed()` (single-frame), no buffering — matches spec
- Existing states: only `tryDash()` calls added, no logic changes — non-breaking
