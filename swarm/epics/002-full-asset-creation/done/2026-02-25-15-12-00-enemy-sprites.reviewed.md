# Task: Sprite Sheets and Animation Controllers for All 3 Enemy Types

## Overview

Add sprite sheet definitions, animation controllers, and RenderConfig-aware rendering to all 3 enemy types (Reader, Binder, Proofwarden). Follow the exact same pattern established in `Player.ts` — private sprite fields, `initSprites()` in constructor, state-driven animation in `update()`, and dual-mode rendering in `render()`. Each enemy's existing hand-crafted rectangle rendering (bob, tilt, thread, shield, etc.) is preserved as the "rectangles" mode; sprites replace only the body rectangle.

## What to Build

### 1. Create `src/engine/entities/enemies/EnemySprites.ts`

A single file defining all enemy sprite configs, animations, and state→animation mappings — one section per enemy type. Follows the `PlayerSprites.ts` pattern exactly.

**Reader sprites** (48×48 frames):

| Sheet ID | Filename | Frames | Cols | Animations |
|----------|----------|--------|------|------------|
| `reader-idle` | `reader-idle-sheet.png` | 2 | 2 | `idle`: [0,1] @ 4fps, loop |
| `reader-rush` | `reader-rush-sheet.png` | 4 | 4 | `rush`: [0,1,2,3] @ 10fps, loop |
| `reader-hit` | `reader-hit-sheet.png` | 2 | 2 | `hit`: [0,1] @ 6fps, no-loop |
| `reader-death` | `reader-death-sheet.png` | 3 | 3 | `death`: [0,1,2] @ 6fps, no-loop |

```typescript
export const READER_STATE_TO_ANIMATION: Record<string, { sheetId: string; animName: string }> = {
  PATROL:  { sheetId: "reader-idle",  animName: "idle" },
  CHASE:   { sheetId: "reader-rush",  animName: "rush" },
  ATTACK:  { sheetId: "reader-rush",  animName: "rush" },
  RECOVER: { sheetId: "reader-idle",  animName: "idle" },
  HURT:    { sheetId: "reader-hit",   animName: "hit" },
  DEAD:    { sheetId: "reader-death", animName: "death" },
};
```

**Binder sprites** (64×64 frames):

| Sheet ID | Filename | Frames | Cols | Animations |
|----------|----------|--------|------|------------|
| `binder-idle` | `binder-idle-sheet.png` | 2 | 2 | `idle`: [0,1] @ 3fps, loop |
| `binder-grapple` | `binder-grapple-sheet.png` | 5 | 5 | `grapple-extend`: [0,1,2] @ 8fps, no-loop; `grapple-retract`: [3,4] @ 8fps, no-loop |
| `binder-hit` | `binder-hit-sheet.png` | 2 | 2 | `hit`: [0,1] @ 6fps, no-loop |
| `binder-death` | `binder-death-sheet.png` | 3 | 3 | `death`: [0,1,2] @ 6fps, no-loop |

```typescript
export const BINDER_STATE_TO_ANIMATION: Record<string, { sheetId: string; animName: string }> = {
  IDLE:           { sheetId: "binder-idle",    animName: "idle" },
  WINDUP:         { sheetId: "binder-grapple", animName: "grapple-extend" },
  THREAD_FIRE:    { sheetId: "binder-grapple", animName: "grapple-extend" },
  PULLING:        { sheetId: "binder-grapple", animName: "grapple-retract" },
  THREAD_RETRACT: { sheetId: "binder-grapple", animName: "grapple-retract" },
  HURT:           { sheetId: "binder-hit",     animName: "hit" },
  DEAD:           { sheetId: "binder-death",   animName: "death" },
};
```

**Proofwarden sprites** (64×64 frames):

| Sheet ID | Filename | Frames | Cols | Animations |
|----------|----------|--------|------|------------|
| `proofwarden-idle` | `proofwarden-idle-sheet.png` | 2 | 2 | `idle`: [0,1] @ 3fps, loop |
| `proofwarden-shield` | `proofwarden-shield-sheet.png` | 5 | 5 | `shield-up`: [0,1] @ 4fps, loop; `shield-break`: [2,3,4] @ 8fps, no-loop |
| `proofwarden-attack` | `proofwarden-attack-sheet.png` | 3 | 3 | `slam`: [0,1,2] @ 8fps, no-loop |
| `proofwarden-hit` | `proofwarden-hit-sheet.png` | 2 | 2 | `hit`: [0,1] @ 6fps, no-loop |
| `proofwarden-death` | `proofwarden-death-sheet.png` | 3 | 3 | `death`: [0,1,2] @ 6fps, no-loop |

```typescript
export const PROOFWARDEN_STATE_TO_ANIMATION: Record<string, { sheetId: string; animName: string }> = {
  PATROL:        { sheetId: "proofwarden-idle",   animName: "idle" },
  CHASE:         { sheetId: "proofwarden-idle",   animName: "idle" },
  SLAM_WINDUP:   { sheetId: "proofwarden-attack", animName: "slam" },
  SLAM_ACTIVE:   { sheetId: "proofwarden-attack", animName: "slam" },
  SLAM_RECOVERY: { sheetId: "proofwarden-attack", animName: "slam" },
  HURT:          { sheetId: "proofwarden-hit",    animName: "hit" },
  DEAD:          { sheetId: "proofwarden-death",  animName: "death" },
};
```

Also export a helper to get all sprite configs for a given enemy type:
```typescript
export function getEnemySpriteConfigs(type: "reader" | "binder" | "proofwarden"): SpriteSheetConfig[]
export function getEnemyAnimations(type: "reader" | "binder" | "proofwarden"): Record<string, AnimationDef[]>
export function getEnemyStateToAnimation(type: "reader" | "binder" | "proofwarden"): Record<string, { sheetId: string; animName: string }>
```

### 2. Add Sprite Support to the Base `Enemy` Class

Modify `src/engine/entities/Enemy.ts` to add sprite infrastructure that subclasses can opt into:

```typescript
// New imports
import { AnimationController } from "@/engine/core/AnimationController";
import { AssetManager } from "@/engine/core/AssetManager";
import type { SpriteSheetConfig, AnimationDef } from "@/engine/core/SpriteSheet";

// New protected fields on Enemy:
protected animControllers = new Map<string, AnimationController>();
protected activeAnimController: AnimationController | null = null;
protected spritesReady = false;
protected stateToAnimation: Record<string, { sheetId: string; animName: string }> = {};
```

Add a protected `initSprites()` method on the base class:
```typescript
protected async initSprites(
  configs: SpriteSheetConfig[],
  animations: Record<string, AnimationDef[]>,
  stateToAnim: Record<string, { sheetId: string; animName: string }>
): Promise<void> {
  this.stateToAnimation = stateToAnim;
  const assetManager = AssetManager.getInstance();
  const sheets = await assetManager.loadAll(configs);
  for (const sheet of sheets) {
    const anims = animations[sheet.config.id];
    if (anims) {
      for (const anim of anims) {
        sheet.addAnimation(anim);
      }
    }
    this.animControllers.set(sheet.config.id, new AnimationController(sheet));
  }
  this.spritesReady = true;
}
```

Add a protected `updateAnimation(dt)` method:
```typescript
protected updateAnimation(dt: number): void {
  if (!this.spritesReady) return;
  const state = this.stateMachine.getCurrentState();
  const mapping = this.stateToAnimation[state];
  if (mapping) {
    const controller = this.animControllers.get(mapping.sheetId);
    if (controller) {
      this.activeAnimController = controller;
      controller.play(mapping.animName);
      controller.update(dt);
    }
  }
}
```

Update `renderBase()` — replace the TODO stub with real sprite rendering:
```typescript
// In renderBase(), replace the body rendering section:
if (RenderConfig.useSprites() && this.spritesReady && this.activeAnimController) {
  const sheet = this.activeAnimController.getSpriteSheet();
  if (sheet.isLoaded()) {
    const ctx = renderer.getContext();
    const spriteOffsetX = (sheet.config.frameWidth - this.size.x) / 2;
    const spriteOffsetY = sheet.config.frameHeight - this.size.y;
    // Hit flash: draw white-tinted sprite
    if (this.hitFlashTimer > 0) {
      ctx.globalCompositeOperation = "source-atop";
      // Draw sprite, then overlay white
    }
    this.activeAnimController.draw(ctx, pos.x - spriteOffsetX, pos.y - spriteOffsetY, !this.facingRight);
  }
}
if (RenderConfig.useRectangles()) {
  renderer.fillRect(pos.x, pos.y, this.size.x, this.size.y, bodyColor);
}
```

For hit flash on sprites: the simplest approach is to temporarily swap the sprite's `globalAlpha` or draw a white rect overlay. Match what `Player.ts` does — if Player doesn't handle sprite hit flash yet, just draw the sprite normally and skip the white flash in sprite mode (it's cosmetic, can be polished later).

### 3. Integrate Sprites into Each Enemy Subclass

**Reader.ts** — modify:
- Import sprite configs from `EnemySprites.ts`
- Call `this.initSprites(getEnemySpriteConfigs("reader"), getEnemyAnimations("reader"), READER_STATE_TO_ANIMATION)` at end of constructor
- Call `this.updateAnimation(dt)` at the end of `updateBase()` call in its update flow (after state machine runs)
- In `render()`: wrap the existing per-state visual effects (bob, tilt, afterimages) in `if (RenderConfig.useRectangles()) { ... }`. The sprite rendering happens via `renderBase()`. Each enemy already calls `renderBase()` or `super.render()` — verify the flow and adjust so that:
  - Sprite mode: `renderBase()` draws the sprite body + health bar + state label
  - Rectangle mode: the enemy's custom `render()` draws the hand-crafted colored rect with bob/tilt effects, THEN calls `renderBase()` only for the health bar/state label (skip body rect)

**Key insight about render flow**: Currently each enemy's `render()` method does its own full rendering and typically does NOT call `renderBase()` — it reimplements everything. The cleanest integration:

1. In each enemy's `render()`, first call sprite rendering if sprites mode:
```typescript
if (RenderConfig.useSprites() && this.spritesReady && this.activeAnimController) {
  // Let base class handle sprite body drawing
  // (extract sprite drawing from renderBase into a protected helper)
}
```

2. Wrap the existing rectangle visuals in `if (RenderConfig.useRectangles()) { ... }`

3. Keep health bar, state label, and non-body overlays (thread line, shield arc, slam hitbox) unconditional — they render in all modes.

**Important**: The Reader's afterimage trail, Binder's thread line, and Proofwarden's shield arc + slam hitbox overlay are NOT body sprites — they render on top of the body in both modes. Only the body rectangle itself gets replaced by the sprite.

**Binder.ts** — modify:
- Same pattern as Reader
- The thread rendering (line, arc, targeting overlay) remains unconditional — it's drawn on top of the body
- The idle pulse (`idleScaleX`) is a rectangle-mode visual only — skip in sprite mode

**Proofwarden.ts** — modify:
- Same pattern as Reader
- The shield arc rendering remains unconditional (it's a gameplay indicator, not a body visual)
- The `bodyScaleY` squash-stretch during slam is a rectangle-mode visual only — skip in sprite mode
- The slam hitbox overlay remains unconditional (debug/gameplay indicator)

### 4. Register Enemy Placeholder Colors in `AssetManager.ts`

Modify `src/engine/core/AssetManager.ts` to recognize enemy sprite sheet ID prefixes for placeholder colors:
- `reader-*` → `#ef4444` (red — matches the existing enemy placeholder color from epic description)
- `binder-*` → `#a855f7` (purple — visually distinct)
- `proofwarden-*` → `#3b82f6` (blue — visually distinct)

The `createPlaceholder()` method likely checks the sheet ID prefix to pick a color. Add these prefixes to whatever mapping exists.

### 5. Add Enemy Sprite Prompts to `scripts/generate-assets.ts`

Add 13 new prompts to the `ASSET_PROMPTS` array (4 Reader + 4 Binder + 5 Proofwarden sheets):

**Reader prompts** (each 48×48 frames):
```
reader-idle-sheet.png: "${STYLE_PREFIX} sprite sheet of a small frantic book creature called a Reader, 2 frames side by side, idle pose with pages fluttering nervously, hunched posture with visible spine ridges, each frame 48x48 pixels, red and dark parchment tones, game sprite sheet, 96x48 total"

reader-rush-sheet.png: "${STYLE_PREFIX} sprite sheet of a small frantic book creature called a Reader rushing forward, 4 frames side by side, scrambling run with pages flying off, limbs flailing, speed lines, each frame 48x48 pixels, red and dark parchment tones, game sprite sheet, 192x48 total"

reader-hit-sheet.png: "${STYLE_PREFIX} sprite sheet of a small book creature called a Reader getting hit, 2 frames side by side: recoil with pages scattering, dazed with stars, each frame 48x48 pixels, red and parchment tones, game sprite sheet, 96x48 total"

reader-death-sheet.png: "${STYLE_PREFIX} sprite sheet of a small book creature called a Reader dying, 3 frames side by side: crumpling inward, pages exploding outward, pile of loose pages on ground, each frame 48x48 pixels, red fading to gray tones, game sprite sheet, 144x48 total"
```

**Binder prompts** (each 64×64 frames):
```
binder-idle-sheet.png: "${STYLE_PREFIX} sprite sheet of a hunched thread-caster creature called a Binder, 2 frames side by side, idle weaving pose with glowing threads between hands, robed figure with thread tendrils, each frame 64x64 pixels, purple and dark ink tones, game sprite sheet, 128x64 total"

binder-grapple-sheet.png: "${STYLE_PREFIX} sprite sheet of a thread-caster creature called a Binder shooting and retracting a thread, 5 frames in a row: arm extending with thread launching forward, thread stretching out, thread taut at full extension, thread pulling back with tension, arm retracted with thread coiled, each frame 64x64 pixels, purple and glowing thread tones, game sprite sheet, 320x64 total"

binder-hit-sheet.png: "${STYLE_PREFIX} sprite sheet of a robed thread-caster creature getting hit, 2 frames side by side: flinch with threads snapping, recoil with arms raised, each frame 64x64 pixels, purple and parchment tones, game sprite sheet, 128x64 total"

binder-death-sheet.png: "${STYLE_PREFIX} sprite sheet of a robed thread-caster creature dying, 3 frames side by side: collapsing with threads unraveling, dissolving into loose threads, pile of tangled threads on ground, each frame 64x64 pixels, purple fading to gray, game sprite sheet, 192x64 total"
```

**Proofwarden prompts** (each 64×64 frames):
```
proofwarden-idle-sheet.png: "${STYLE_PREFIX} sprite sheet of an armored sentinel creature called a Proofwarden, 2 frames side by side, imposing stance with glowing shield in one hand, ink-etched armor with proofreading marks, each frame 64x64 pixels, blue and iron gray tones, game sprite sheet, 128x64 total"

proofwarden-shield-sheet.png: "${STYLE_PREFIX} sprite sheet of an armored sentinel raising and losing its shield, 5 frames in a row: shield raised with bright glow, shield at full power with energy aura, shield cracking with sparks, shield shattering with fragments, shield gone with staggered pose, each frame 64x64 pixels, blue glow to dim gray transition, game sprite sheet, 320x64 total"

proofwarden-attack-sheet.png: "${STYLE_PREFIX} sprite sheet of an armored sentinel doing a ground slam attack, 3 frames in a row: winding up with fist raised high, slamming down with shockwave ring, impact with ground crack lines radiating outward, each frame 64x64 pixels, blue and iron tones with impact yellow, game sprite sheet, 192x64 total"

proofwarden-hit-sheet.png: "${STYLE_PREFIX} sprite sheet of an armored sentinel getting hit, 2 frames side by side: armor sparking on impact, staggering backward, each frame 64x64 pixels, blue and iron gray tones, game sprite sheet, 128x64 total"

proofwarden-death-sheet.png: "${STYLE_PREFIX} sprite sheet of an armored sentinel dying, 3 frames side by side: armor cracking and falling off, collapsing to knees with ink leaking, crumpled armor pile on ground, each frame 64x64 pixels, iron gray fading to black, game sprite sheet, 192x64 total"
```

All prompts use `aspectRatio: "16:9"` to match the existing pattern.

## Files to Create/Modify

| File | Action |
|------|--------|
| `src/engine/entities/enemies/EnemySprites.ts` | **Create** — all enemy sprite sheet configs, animation defs, state-to-animation mappings, helper functions |
| `src/engine/entities/Enemy.ts` | **Modify** — add protected sprite fields, `initSprites()`, `updateAnimation()`, update `renderBase()` sprite branch |
| `src/engine/entities/enemies/Reader.ts` | **Modify** — call `initSprites()` in constructor, `updateAnimation()` in update, wrap rectangle visuals in RenderConfig check |
| `src/engine/entities/enemies/Binder.ts` | **Modify** — same pattern as Reader |
| `src/engine/entities/enemies/Proofwarden.ts` | **Modify** — same pattern as Reader |
| `src/engine/core/AssetManager.ts` | **Modify** — add enemy placeholder color prefixes |
| `scripts/generate-assets.ts` | **Modify** — add 13 new enemy sprite prompts |

## What NOT to Do

- Do NOT modify the Player class or PlayerSprites — those are separate tasks
- Do NOT generate actual image files — just define configs and prompts
- Do NOT add new enemy states or modify AI behavior
- Do NOT change how non-body overlays render (thread, shield, slam hitbox, health bar, state label) — these stay unconditional
- Do NOT modify test pages — the existing render mode toggle will automatically pick up the new sprite rendering
- Do NOT modify `RenderConfig.ts` — it's already complete

## Verification / Pass Criteria

1. **TypeScript compiles**: `npx tsc --noEmit` passes with no errors
2. **Existing tests pass**: `npm run test:run` still passes (headless tests don't load sprites)
3. **All enemy states mapped**: Every Reader state (6), Binder state (7), and Proofwarden state (7) has an entry in its STATE_TO_ANIMATION
4. **Sprite configs correct**: Reader has 4 sheets (48×48), Binder has 4 sheets (64×64), Proofwarden has 5 sheets (64×64) = 13 total
5. **Rectangle mode unchanged**: With RenderConfig set to "rectangles", every enemy renders exactly as before (bob, tilt, thread, shield, etc. — zero visual change)
6. **Sprite mode renders placeholders**: With RenderConfig set to "sprites", enemies show colored-rectangle placeholders with frame numbers (red for Reader, purple for Binder, blue for Proofwarden)
7. **Non-body overlays render in both modes**: Thread lines (Binder), shield arcs (Proofwarden), slam hitboxes (Proofwarden), health bars, and state labels all render regardless of render mode
8. **Death animation plays**: Enemy death state drives the death animation (sprite mode) or the existing shrink animation (rectangle mode) before the entity is removed
9. **Generate script updated**: `ASSET_PROMPTS` array has 13 new enemy prompts (24 total), all with correct filenames matching sprite sheet IDs
10. **No console errors**: Enemy sprite initialization fails gracefully if images don't exist (AssetManager provides placeholders automatically)

---

## Implementation Summary

### Files Created
- **`src/engine/entities/enemies/EnemySprites.ts`** — All enemy sprite sheet configs (13 sheets: 4 Reader @ 48×48, 4 Binder @ 64×64, 5 Proofwarden @ 64×64), animation definitions, state→animation mappings for all 20 enemy states, and helper functions (`getEnemySpriteConfigs`, `getEnemyAnimations`, `getEnemyStateToAnimation`)

### Files Modified
- **`src/engine/entities/Enemy.ts`** — Added sprite infrastructure to base class: `AnimationController`/`AssetManager`/`SpriteSheet` imports, protected sprite fields (`animControllers`, `activeAnimController`, `spritesReady`, `stateToAnimation`), `initSprites()` method (async load with graceful fallback), `updateAnimation()` method (state-driven animation selection), `renderSpriteBody()` helper, and updated `renderBase()` to support both sprite and rectangle rendering in alive and death states
- **`src/engine/entities/enemies/Reader.ts`** — Added sprite imports, `initSprites()` call in constructor, `updateAnimation(dt)` in update, wrapped body rectangle rendering (afterimages, bob, tilt) in `RenderConfig.useRectangles()`, added `renderSpriteBody()` calls in sprite mode
- **`src/engine/entities/enemies/Binder.ts`** — Same pattern as Reader: sprite init, animation update, idle pulse body wrapped in `useRectangles()`, sprite body rendering added. Thread/targeting overlays remain unconditional
- **`src/engine/entities/enemies/Proofwarden.ts`** — Same pattern: sprite init, animation update, body squash-stretch wrapped in `useRectangles()`, sprite body rendering added. Shield arc, slam hitbox, health bar, state label all remain unconditional
- **`src/engine/core/AssetManager.ts`** — Added placeholder color prefixes: `reader` → red (#ef4444), `binder` → purple (#a855f7), `proofwarden` → blue (#3b82f6)
- **`scripts/generate-assets.ts`** — Added 13 new enemy sprite prompts (4 Reader + 4 Binder + 5 Proofwarden), bringing total to 24 asset prompts

### Verification
- `npx tsc --noEmit` — passes with no errors
- `npm run test:run` — all 427 tests pass (16 test files)
- All state mappings verified: Reader (6 states), Binder (7 states), Proofwarden (7 states) — all mapped

---

## Review Notes (reviewer: 3fa6bc11)

### Issues Found & Fixed

1. **Animation advancing during hitstop (Enemy.ts)** — `updateAnimation(dt)` was called after `updateBase(dt)` in all three subclasses' `update()` methods. Since `updateBase()` returns early during hitstop (to freeze the enemy), but `updateAnimation()` was called afterward unconditionally, the sprite animation would keep advancing during hitstop frames, breaking the visual freeze effect. **Fixed** by adding an early return in `updateAnimation()` when `hitstopTimer > 0`.

### Verified Correct

- **EnemySprites.ts**: All 13 sprite configs correct (4 Reader @ 48x48, 4 Binder @ 64x64, 5 Proofwarden @ 64x64). All animation defs match spec. All 20 enemy states mapped.
- **Enemy.ts**: Base class sprite infrastructure (initSprites, updateAnimation, renderSpriteBody, dual-mode renderBase) follows Player.ts pattern. Async loading with graceful fallback. Hit flash correctly applies only to rectangle mode.
- **Reader.ts**: Sprite init in constructor, updateAnimation in update, afterimages/bob/tilt wrapped in useRectangles(), sprite body rendering added for PATROL and CHASE states. Health bar and state label render in all modes.
- **Binder.ts**: Same pattern. Thread/targeting overlays remain unconditional. Idle pulse body wrapped in useRectangles().
- **Proofwarden.ts**: Same pattern. Shield arc, slam hitbox, health bar, state label all unconditional. Body squash-stretch wrapped in useRectangles().
- **AssetManager.ts**: Placeholder colors correct (reader=red, binder=purple, proofwarden=blue).
- **generate-assets.ts**: 13 new enemy prompts added, 24 total. All filenames match sprite sheet IDs. All use 16:9 aspect ratio.
- **TypeScript compiles clean**, all 427 tests pass after fix.

### Notes

- The `proofwarden-shield` sprite sheet (shield-up/shield-break animations) is defined but not mapped to any state in PROOFWARDEN_STATE_TO_ANIMATION. The shield visual is rendered as a geometric arc overlay instead. The sheet is ready for future use when more sophisticated sprite-based shield rendering is needed.
