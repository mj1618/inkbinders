# Task: Enemies — Reader, Binder, Proofwarden Archetypes

## Overview

Implement the **enemy system** and its test page (`/test/enemies`). This is Phase 3, step 14. It introduces three enemy archetypes — **Reader** (rush), **Binder** (grapple), and **Proofwarden** (shield) — with full AI, player detection, attack patterns, and interaction with the combat system.

**This task depends on the combat-melee task being complete.** It uses the `CombatSystem`, `Damageable` interface, `AttackHitbox`, `HitResult`, and combat types established there.

**Core design principle:** Enemies are gameplay puzzles, not HP sponges. Each archetype teaches the player a different skill:
- **Reader** teaches aggression — you must attack before it reaches you
- **Binder** teaches positioning — stay mid-range, don't let it pull you in
- **Proofwarden** teaches spatial awareness — attack from behind or above

## Dependencies

- Phase 1 movement system ✅
- Combat system (`src/engine/combat/`) — CombatSystem, Damageable, AttackHitbox, HitResult, combat types ✅ (from combat-melee task)
- Entity system ✅ (Entity base class)
- StateMachine ✅
- TileMap collision ✅
- ParticleSystem, ScreenShake ✅
- InputManager (Attack, WeaponSwitch actions) ✅

## What to Build

### 1. Enemy Base Class (`src/engine/entities/Enemy.ts`)

A shared base class for all enemy types. Extends `Entity`, implements `Damageable` (from `src/engine/combat/types.ts`).

```typescript
import { Entity } from "./Entity";
import { StateMachine } from "@/engine/states/StateMachine";
import type { TileMap } from "@/engine/physics/TileMap";
import type { ParticleSystem } from "@/engine/core/ParticleSystem";
import type { Damageable } from "@/engine/combat/types";
import type { Vec2, Rect } from "@/lib/types";

export interface EnemyConfig {
  position: Vec2;
  size: Vec2;
  color: string;
  health: number;
  contactDamage: number;
  /** Whether this enemy respawns after death (for test page) */
  respawns: boolean;
  /** Frames before respawning */
  respawnDelay: number;
}

export abstract class Enemy extends Entity implements Damageable {
  // --- Damageable ---
  health: number;
  maxHealth: number;
  knockbackVelocity: Vec2 = { x: 0, y: 0 };
  hitstunFrames: number = 0;
  invincibilityFrames: number = 0;
  isAlive: boolean = true;

  // --- Physics ---
  tileMap: TileMap | null = null;
  grounded: boolean = false;
  facingRight: boolean = true;
  gravity: number = 980;     // px/s²
  maxFallSpeed: number = 600;

  // --- Combat ---
  contactDamage: number;
  contactKnockback: number = 300;  // px/s applied to player on contact
  hitstopTimer: number = 0;

  // --- Visual ---
  hitFlashTimer: number = 0;
  deathTimer: number = 0;

  // --- Respawn ---
  spawnPosition: Vec2;
  respawns: boolean;
  respawnDelay: number;
  respawnTimer: number = 0;

  // --- State Machine ---
  abstract stateMachine: StateMachine<unknown>;

  // --- Player reference (set externally) ---
  playerRef: { position: Vec2; velocity: Vec2; size: Vec2; getBounds(): Rect; facingRight: boolean; grounded: boolean; isDashing: boolean; stateMachine: { getCurrentState(): string } } | null = null;

  // --- Particle system reference (set externally) ---
  particleSystem: ParticleSystem | null = null;

  constructor(config: EnemyConfig);

  /** Whether this enemy can currently be damaged */
  canBeDamaged(): boolean;  // alive && invincibilityFrames <= 0 && hitstopTimer <= 0

  /** Apply damage and knockback from a player attack */
  takeDamage(damage: number, knockback: Vec2, hitstopFrames: number): boolean;

  /** Check if the player is within detection range */
  canSeePlayer(detectionRange: number): boolean;

  /** Get distance to the player center */
  distanceToPlayer(): number;

  /** Get direction to the player (-1 left, 1 right) */
  directionToPlayer(): number;

  /** Common update: gravity, collision, hitstop, hitstun, knockback, invincibility, death, respawn */
  updateBase(dt: number): void;

  /** Common render: body rect with hit flash, health bar, hitstop glow */
  renderBase(renderer: Renderer, interpolation: number): void;

  /** Spawn death particles */
  spawnDeathParticles(): void;

  /** Reset to spawn state */
  reset(): void;
}
```

**`updateBase(dt)` sequence:**
1. If `hitstopTimer > 0`: decrement, skip ALL updates (enemy is frozen). Return early.
2. If `!isAlive`: decrement `respawnTimer`, if 0 and `respawns`, call `reset()`. Return early.
3. Decrement `invincibilityFrames`, `hitstunFrames`, `hitFlashTimer`.
4. If `hitstunFrames > 0`: apply knockback decay (friction), apply gravity to knockbackVelocity.y, move by knockbackVelocity. Resolve collisions. Return (skip AI).
5. Snapshot `prevPosition`.
6. Call `stateMachine.update(dt)` — this runs the AI.
7. Apply gravity: `velocity.y += gravity * dt`, clamp to `maxFallSpeed`.
8. Integrate: `position += velocity * dt`.
9. Resolve collisions: `tileMap.resolveCollisions(this)` → set `grounded`.
10. Face toward player if in chase/attack states.

### 2. Reader Enemy (`src/engine/entities/enemies/Reader.ts`)

**Theme:** A corrupted page fragment that rushes at the player. Fast, aggressive, low HP. Think "Tektite meets Hollow Knight's Crawlid."

**Stats:**
| Param | Value | Description |
|-------|-------|-------------|
| `health` | 2 | Dies fast — meant to swarm |
| `size` | { x: 20, y: 24 } | Small |
| `moveSpeed` | 160 | px/s patrol speed |
| `chaseSpeed` | 300 | px/s rush speed |
| `detectionRange` | 200 | px — starts chasing |
| `attackRange` | 30 | px — lunges when close |
| `lungeSpeed` | 500 | px/s — burst speed during attack |
| `lungeDuration` | 10 | frames of lunge |
| `lungeRecovery` | 30 | frames stunned after lunge miss |
| `contactDamage` | 1 | |
| `lungeKnockback` | 200 | px/s knockback to player on lunge hit |
| `color` | `#ef4444` | Red |

**State Machine:**

| State | Behavior |
|-------|----------|
| `PATROL` | Walk back and forth on a platform. Reverse at ledges (check for ground 1 tile ahead). Speed: `moveSpeed`. Transition to `CHASE` when player enters `detectionRange`. |
| `CHASE` | Run toward the player at `chaseSpeed`. Still respects ledge detection (won't run off platforms). Transition to `ATTACK` when within `attackRange`. Transition back to `PATROL` if player leaves `detectionRange * 1.5` (hysteresis). |
| `ATTACK` | Lunge in the player's direction. Fixed velocity for `lungeDuration` frames. Ignores ledge detection during lunge (commits to the attack). After lunge: transition to `RECOVER`. |
| `RECOVER` | Stunned for `lungeRecovery` frames after a missed lunge. Skids to a stop. Transition to `CHASE` when recovery ends if player still in range, else `PATROL`. |
| `HURT` | Entered when taking damage. Plays knockback from `updateBase`. Transitions to `PATROL` or `CHASE` when hitstun ends. |
| `DEAD` | Entered when health <= 0. Plays death particles. Entity becomes inactive. Respawn timer starts. |

**Ledge detection:** Before moving horizontally, probe 1px below and 1px ahead of the leading edge. If no ground platform there, reverse direction (PATROL) or stop (CHASE — don't run off edges).

**Contact damage:** While in CHASE or ATTACK state, if the Reader's bounds overlap the player's bounds, deal `contactDamage` to the player.

### 3. Binder Enemy (`src/engine/entities/enemies/Binder.ts`)

**Theme:** A corrupted book binding that extends a thread to grapple the player. Stationary sentinel that punishes players who stay at range.

**Stats:**
| Param | Value | Description |
|-------|-------|-------------|
| `health` | 4 | Medium durability |
| `size` | { x: 28, y: 36 } | Wider, medium height |
| `detectionRange` | 250 | px — starts tracking |
| `threadRange` | 180 | px — max grapple reach |
| `threadMinRange` | 50 | px — won't grapple if player is very close |
| `threadSpeed` | 400 | px/s — speed of the extending thread |
| `threadRetractSpeed` | 300 | px/s — speed the thread pulls the player |
| `threadWindup` | 20 | frames — telegraph before firing |
| `threadDuration` | 40 | frames — max time thread stays extended |
| `threadCooldown` | 90 | frames between grapple attempts |
| `pullDuration` | 30 | frames — how long the pull lasts |
| `contactDamage` | 1 | Damage on player overlap |
| `threadDamage` | 1 | Damage when thread connects |
| `threadKnockback` | 150 | px/s pull toward Binder |
| `color` | `#a855f7` | Purple |

**State Machine:**

| State | Behavior |
|-------|----------|
| `IDLE` | Stationary. Slight idle bob animation. Faces toward player if in `detectionRange`. Transition to `WINDUP` when player is within `threadRange` and outside `threadMinRange` and cooldown is 0. |
| `WINDUP` | Telegraph: body pulses, a targeting line appears between Binder and player. Lasts `threadWindup` frames. If player leaves range during windup, cancel → `IDLE`. Transition to `THREAD_FIRE` when timer expires. |
| `THREAD_FIRE` | Fire a thread projectile toward the player's position at moment of fire (not tracking). The thread extends as a line from the Binder toward the target point at `threadSpeed`. If the thread tip overlaps the player's bounds → `PULLING`. If the thread reaches max extension without hitting → `THREAD_RETRACT`. |
| `PULLING` | Thread connected! Apply a pull force to the player: add velocity toward the Binder at `threadRetractSpeed` each frame for `pullDuration` frames. Deal `threadDamage` on connection. The player can dash to break the thread (if player enters DASHING state, thread snaps → `THREAD_RETRACT`). Thread visually stretches between Binder and player. |
| `THREAD_RETRACT` | Thread retracts back to the Binder. Cooldown starts. Transition to `IDLE` when retracted. |
| `HURT` | Taking damage. Knockback from `updateBase`. If hit during WINDUP or THREAD_FIRE, the thread is cancelled. Transitions based on hitstun. |
| `DEAD` | Death particles, inactive, respawn timer. |

**Thread rendering:** The thread is a line drawn from the Binder's center to the thread tip (or the player during PULLING). Color: `#7c3aed` (darker purple). Draw with 2px width. During WINDUP, draw a dashed targeting line (alternating 4px on/off) from Binder to player in `#7c3aed44` (transparent purple).

**Player interaction during PULLING:** The Binder adds velocity to the player toward itself. The player can still move (reduced effectiveness — the pull is a constant force, not a position override). The player can dash to break free (check if player state is DASHING during pull → snap thread). This creates a tug-of-war feel.

**Implementation note for PULLING:** The Binder doesn't directly modify `player.velocity`. Instead, it exposes a `pullForce: Vec2 | null` field. The test page update callback reads `pullForce` and applies it to the player's velocity each frame. This keeps the enemy decoupled from the Player class.

### 4. Proofwarden Enemy (`src/engine/entities/enemies/Proofwarden.ts`)

**Theme:** An armored proofreader construct with a directional shield. Blocks frontal attacks. Must be attacked from behind or above.

**Stats:**
| Param | Value | Description |
|-------|-------|-------------|
| `health` | 6 | Tanky |
| `size` | { x: 32, y: 40 } | Large |
| `moveSpeed` | 80 | px/s — slow patrol |
| `chaseSpeed` | 120 | px/s — slow chase |
| `detectionRange` | 180 | px |
| `attackRange` | 40 | px — melee slam range |
| `slamWindup` | 25 | frames — long telegraph |
| `slamActiveFrames` | 6 | frames — hitbox is active |
| `slamRecovery` | 40 | frames — punishable window |
| `slamDamage` | 2 | Higher damage |
| `slamKnockback` | 350 | px/s |
| `slamHitbox` | { width: 60, height: 30 } | Wide slam in front |
| `shieldBlockAngle` | 120 | degrees — frontal arc that blocks |
| `contactDamage` | 1 | |
| `color` | `#f59e0b` | Amber |
| `shieldColor` | `#fbbf24` | Lighter amber for shield |

**State Machine:**

| State | Behavior |
|-------|----------|
| `PATROL` | Walk slowly back and forth. Respects ledges. Shield always faces forward (movement direction). Transition to `CHASE` on player detection. |
| `CHASE` | Walk toward the player at `chaseSpeed`. Always faces the player. Shield faces player. Transition to `SLAM_WINDUP` when within `attackRange`. Back to `PATROL` if player leaves range × 1.5. |
| `SLAM_WINDUP` | Stop moving. Shield flashes. Body raises up (visual squash/stretch: scaleY increases slightly). Lasts `slamWindup` frames. This is the telegraph — player should recognize and get behind. Transition to `SLAM_ACTIVE`. |
| `SLAM_ACTIVE` | Slam hitbox appears in front. Deals `slamDamage` with `slamKnockback` to player if overlapping. Lasts `slamActiveFrames`. Screen shake on slam (even if miss). Transition to `SLAM_RECOVERY`. |
| `SLAM_RECOVERY` | Exhausted after slam. No shield! (shield deactivated during recovery). This is the punish window — player can attack from any direction. Lasts `slamRecovery` frames. Transition to `CHASE` or `PATROL`. |
| `HURT` | Taking damage (only from unshielded side). Knockback. |
| `DEAD` | Death particles, respawn. |

**Shield mechanics:**

The shield is NOT a separate entity — it's a directional damage filter on the Proofwarden itself.

When the Proofwarden takes damage (`takeDamage` is called), it checks the attack direction:
1. Compute the angle from the Proofwarden's center to the attack hitbox center.
2. Compute the Proofwarden's "shield facing" angle (0° = right, 180° = left, based on `facingRight`).
3. If the angular difference between the attack angle and shield facing is within `shieldBlockAngle / 2`: **BLOCKED**. No damage, no knockback. Play a shield-clang effect (particles: sparks, screen shake: small).
4. Otherwise: damage goes through normally.

The shield is disabled during `SLAM_RECOVERY` — all attacks connect during the punish window.

**Shield rendering:** Draw a thick arc/line segment on the Proofwarden's front side. Color: `shieldColor` with white edge. During `SLAM_RECOVERY`, shield disappears (not rendered).

**Slam hitbox:** The slam creates a rectangular hitbox in front of the Proofwarden (like the player's spear hitbox). Position: extends from the Proofwarden's front edge, `slamHitbox.width` forward and `slamHitbox.height` tall, centered vertically on the Proofwarden. Check this against the player's bounds.

### 5. Player Health System (`src/engine/combat/PlayerHealth.ts`)

A lightweight health/damage overlay for the player (same pattern as CombatSystem — parallel, not a player state).

```typescript
export interface PlayerHealthParams {
  maxHealth: number;          // 5
  invincibilityFrames: number; // 60 frames (1 second) after taking damage
  knockbackSpeed: number;      // 200 px/s
  knockbackDuration: number;   // 10 frames
  /** Whether dash i-frames prevent damage */
  dashIFrames: boolean;        // true
}

export const DEFAULT_PLAYER_HEALTH_PARAMS: PlayerHealthParams = {
  maxHealth: 5,
  invincibilityFrames: 60,
  knockbackSpeed: 200,
  knockbackDuration: 10,
  dashIFrames: true,
};

export class PlayerHealth {
  params: PlayerHealthParams;
  health: number;
  maxHealth: number;
  invincibilityTimer: number = 0;
  knockbackTimer: number = 0;
  knockbackDirection: Vec2 = { x: 0, y: 0 };
  lastDamageSource: string = "";

  constructor(params?: Partial<PlayerHealthParams>);

  /** Whether the player can currently take damage */
  canTakeDamage(playerState: string, isDashing: boolean): boolean;
  // false if: invincibilityTimer > 0, or isDashing && dashIFrames

  /** Apply damage to the player. Returns true if damage was applied. */
  takeDamage(damage: number, knockbackDir: Vec2, source: string): boolean;

  /** Update: decrement timers */
  update(): void;

  /** Get the knockback velocity to apply to the player this frame (or null if no knockback) */
  getKnockbackVelocity(): Vec2 | null;

  /** Render health UI: hearts or health bar at top of screen */
  renderHUD(ctx: CanvasRenderingContext2D, canvasWidth: number): void;

  /** Reset to full health */
  reset(): void;
}
```

**Player damage in the test page:** The test page update callback checks:
1. For each alive enemy: does the enemy's bounds overlap the player's bounds? Is the enemy in an attacking state? If yes, call `playerHealth.takeDamage()`.
2. For Binder: is the thread in PULLING state? Apply pull force to player velocity.
3. For Proofwarden: is the slam hitbox active? Check overlap with player.
4. If `playerHealth.getKnockbackVelocity()` returns non-null, add it to `player.velocity`.
5. Flash the player red during invincibility (toggle visibility every 4 frames).

### 6. Enemy Params (`src/engine/entities/enemies/EnemyParams.ts`)

All enemy tunable values in one place for the debug panel.

```typescript
export interface ReaderParams {
  health: number;
  moveSpeed: number;
  chaseSpeed: number;
  detectionRange: number;
  attackRange: number;
  lungeSpeed: number;
  lungeDuration: number;
  lungeRecovery: number;
  contactDamage: number;
  lungeKnockback: number;
}

export const DEFAULT_READER_PARAMS: ReaderParams = {
  health: 2,
  moveSpeed: 160,
  chaseSpeed: 300,
  detectionRange: 200,
  attackRange: 30,
  lungeSpeed: 500,
  lungeDuration: 10,
  lungeRecovery: 30,
  contactDamage: 1,
  lungeKnockback: 200,
};

export interface BinderParams {
  health: number;
  detectionRange: number;
  threadRange: number;
  threadMinRange: number;
  threadSpeed: number;
  threadRetractSpeed: number;
  threadWindup: number;
  threadDuration: number;
  threadCooldown: number;
  pullDuration: number;
  contactDamage: number;
  threadDamage: number;
  threadKnockback: number;
}

export const DEFAULT_BINDER_PARAMS: BinderParams = {
  health: 4,
  detectionRange: 250,
  threadRange: 180,
  threadMinRange: 50,
  threadSpeed: 400,
  threadRetractSpeed: 300,
  threadWindup: 20,
  threadDuration: 40,
  threadCooldown: 90,
  pullDuration: 30,
  contactDamage: 1,
  threadDamage: 1,
  threadKnockback: 150,
};

export interface ProofwardenParams {
  health: number;
  moveSpeed: number;
  chaseSpeed: number;
  detectionRange: number;
  attackRange: number;
  slamWindup: number;
  slamActiveFrames: number;
  slamRecovery: number;
  slamDamage: number;
  slamKnockback: number;
  slamHitboxWidth: number;
  slamHitboxHeight: number;
  shieldBlockAngle: number;
  contactDamage: number;
}

export const DEFAULT_PROOFWARDEN_PARAMS: ProofwardenParams = {
  health: 6,
  moveSpeed: 80,
  chaseSpeed: 120,
  detectionRange: 180,
  attackRange: 40,
  slamWindup: 25,
  slamActiveFrames: 6,
  slamRecovery: 40,
  slamDamage: 2,
  slamKnockback: 350,
  slamHitboxWidth: 60,
  slamHitboxHeight: 30,
  shieldBlockAngle: 120,
  contactDamage: 1,
};
```

### 7. Test Page (`/test/enemies`)

Replace the stub with a full test page.

**Test Level Layout (2880×540, 3× canvas width):**

Three arenas, one for each enemy type, separated by walls with gaps the player can traverse.

```
┌═══════════════════════════════════════════════════════════════════════════════════════════════════════┐
│                                                                                                       │
│  ARENA 1: READERS                    ARENA 2: BINDER                 ARENA 3: PROOFWARDEN            │
│                                                                                                       │
│                                                  ┌─────┐                                             │
│               R1                                  │Binder│                                            │
│    ┌────────────┐                     ┌──────────┘     └───┐              ┌──────┐                   │
│    │  Platform   │    R2              │  High Platform     │              │ Plat  │                   │
│    └────────────┘                     └────────────────────┘              └──────┘                   │
│                         ┌────┐                                                                       │
│  START     R3    R4     │gap │         Binder area         ████    PW1           PW2                 │
│  ████                   │wall│                             ████                                      │
│                         │    │                             ████                                      │
│═══════════════════════════════════════════════════════════════════════════════════════════════════════│
└═══════════════════════════════════════════════════════════════════════════════════════════════════════┘
```

**Arena 1 — Reader Rush (x: 0–960):**
- 4 Readers on the ground floor, some patrolling
- One elevated platform with a Reader for aerial combat testing
- Open space — tests basic rushing and lunging behavior
- Player spawns here

**Arena 2 — Binder Trap (x: 960–1920):**
- 2 Binders positioned on elevated platforms
- One Binder on the ground
- Platforms at varying heights — tests thread mechanics, pulling, and dash escape
- More vertical layout to emphasize the grapple mechanic

**Arena 3 — Proofwarden Gauntlet (x: 1920–2880):**
- 2 Proofwardens on the ground floor
- Platforms above for flanking/getting behind them
- Tight layout that forces the player to learn the shield and slam patterns

**Detailed Platform Layout:**
```typescript
const platforms: Platform[] = [
  // Ground floor (full width)
  { x: 0, y: 460, width: 2880, height: 80 },

  // === Arena 1: Reader Rush ===
  // Left platform (elevated Reader)
  { x: 80, y: 340, width: 160, height: 20 },
  // Right platform (staging area)
  { x: 600, y: 380, width: 120, height: 20 },

  // Arena divider wall (with gap at bottom to pass through)
  { x: 920, y: 0, width: 40, height: 380 },

  // === Arena 2: Binder Trap ===
  // High platform (Binder perch, left)
  { x: 1060, y: 260, width: 160, height: 20 },
  // Mid platform (right side)
  { x: 1360, y: 340, width: 140, height: 20 },
  // Low platform
  { x: 1200, y: 400, width: 100, height: 20 },

  // Arena divider wall
  { x: 1880, y: 0, width: 40, height: 380 },

  // === Arena 3: Proofwarden Gauntlet ===
  // Flanking platforms (for getting behind Proofwardens)
  { x: 2000, y: 320, width: 120, height: 20 },
  { x: 2300, y: 280, width: 140, height: 20 },
  { x: 2600, y: 340, width: 100, height: 20 },

  // Boundaries
  { x: 0, y: 0, width: 2880, height: 20 },       // Ceiling
  { x: 0, y: 0, width: 20, height: 540 },         // Left wall
  { x: 2860, y: 0, width: 20, height: 540 },      // Right wall
];
```

**Enemy Placement:**
```typescript
// Arena 1: Readers
const readers = [
  new Reader({ position: { x: 200, y: 420 }, ...DEFAULT_READER_PARAMS, patrol: true, patrolRange: 100 }),   // R1: ground patrol
  new Reader({ position: { x: 450, y: 420 }, ...DEFAULT_READER_PARAMS, patrol: true, patrolRange: 80 }),    // R2: ground patrol
  new Reader({ position: { x: 600, y: 420 }, ...DEFAULT_READER_PARAMS, patrol: false }),                      // R3: stationary
  new Reader({ position: { x: 100, y: 300 }, ...DEFAULT_READER_PARAMS, patrol: true, patrolRange: 60 }),    // R4: elevated platform
];

// Arena 2: Binders
const binders = [
  new Binder({ position: { x: 1100, y: 224 }, ...DEFAULT_BINDER_PARAMS }),  // On high platform
  new Binder({ position: { x: 1400, y: 304 }, ...DEFAULT_BINDER_PARAMS }),  // On mid platform
  new Binder({ position: { x: 1250, y: 420 }, ...DEFAULT_BINDER_PARAMS }),  // On ground
];

// Arena 3: Proofwardens
const proofwardens = [
  new Proofwarden({ position: { x: 2100, y: 420 }, ...DEFAULT_PROOFWARDEN_PARAMS }),  // PW1
  new Proofwarden({ position: { x: 2500, y: 420 }, ...DEFAULT_PROOFWARDEN_PARAMS }),  // PW2
];
```

**Debug Overlays (on canvas):**
- Player hitbox (cyan outline)
- Player attack hitbox (from CombatSystem — red when active)
- Enemy hitboxes (colored outlines matching enemy color)
- Enemy state label above each enemy (e.g., "PATROL", "CHASE", "ATTACK")
- Enemy health bars (above enemy)
- Detection range circles (dashed, semi-transparent)
- Reader lunge trajectory (arrow showing lunge direction)
- Binder thread (line from Binder to thread tip / player)
- Binder targeting line during windup (dashed)
- Proofwarden shield arc (thick colored arc on front side)
- Proofwarden slam hitbox (red rect during active)
- Player health hearts at top of screen
- Player invincibility flash (blink every 4 frames)
- FPS counter, player state, velocity
- Enemy kill count

**Debug Panel Sections:**

1. **Combat Info** (always visible):
   - Player health: X / 5
   - Current weapon: Quill-Spear / Ink Snap
   - Total enemies alive / total
   - Total kills
   - Total damage taken by player

2. **Reader Params** (collapsed):
   | Parameter | Min | Max | Step | Default |
   |-----------|-----|-----|------|---------|
   | Health | 1 | 10 | 1 | 2 |
   | Move Speed | 50 | 300 | 10 | 160 |
   | Chase Speed | 100 | 500 | 10 | 300 |
   | Detection Range | 50 | 400 | 10 | 200 |
   | Attack Range | 10 | 80 | 5 | 30 |
   | Lunge Speed | 200 | 800 | 25 | 500 |
   | Lunge Duration | 4 | 20 | 1 | 10 |
   | Lunge Recovery | 10 | 60 | 5 | 30 |
   | Contact Damage | 1 | 5 | 1 | 1 |

3. **Binder Params** (collapsed):
   | Parameter | Min | Max | Step | Default |
   |-----------|-----|-----|------|---------|
   | Health | 1 | 10 | 1 | 4 |
   | Detection Range | 100 | 400 | 10 | 250 |
   | Thread Range | 80 | 300 | 10 | 180 |
   | Thread Min Range | 20 | 100 | 5 | 50 |
   | Thread Speed | 200 | 600 | 25 | 400 |
   | Pull Duration | 10 | 60 | 5 | 30 |
   | Thread Cooldown | 30 | 180 | 10 | 90 |
   | Thread Damage | 1 | 5 | 1 | 1 |

4. **Proofwarden Params** (collapsed):
   | Parameter | Min | Max | Step | Default |
   |-----------|-----|-----|------|---------|
   | Health | 1 | 20 | 1 | 6 |
   | Move Speed | 30 | 200 | 10 | 80 |
   | Chase Speed | 50 | 250 | 10 | 120 |
   | Detection Range | 80 | 300 | 10 | 180 |
   | Slam Windup | 10 | 50 | 5 | 25 |
   | Slam Active | 2 | 12 | 1 | 6 |
   | Slam Recovery | 15 | 80 | 5 | 40 |
   | Slam Damage | 1 | 5 | 1 | 2 |
   | Shield Block Angle | 60 | 180 | 10 | 120 |

5. **Player Health Params** (collapsed):
   | Parameter | Min | Max | Step | Default |
   |-----------|-----|-----|------|---------|
   | Max Health | 1 | 20 | 1 | 5 |
   | I-Frames | 20 | 120 | 10 | 60 |
   | Knockback Speed | 50 | 400 | 25 | 200 |
   | Dash I-Frames | toggle | | | true |

6. **Controls** (collapsed):
   - Respawn all enemies button
   - Reset player health button
   - Toggle enemy AI button (pause all AI for testing)
   - Toggle detection range display
   - Per-enemy type toggle (show/hide Readers, Binders, Proofwardens)

7. **Player State** (collapsed):
   - Standard movement params, state, velocity, position

**Pass Criteria (display on page):**

1. Reader patrols back and forth, reverses at ledges
2. Reader detects player and switches to chase (runs toward player)
3. Reader lunges at player when in attack range
4. Reader lunge deals contact damage to player (health decreases)
5. Player can attack and kill Readers (2 hits with spear kills a Reader)
6. Reader shows knockback on hit (flies backward with hitstop)
7. Dead Reader respawns after delay
8. Binder fires thread toward player (visible line projectile)
9. Thread connecting to player applies pull force (player slides toward Binder)
10. Player can dash to break Binder thread
11. Binder can be attacked during windup or recovery
12. Proofwarden shield blocks frontal attacks (no damage, clang effect)
13. Proofwarden can be damaged from behind or above
14. Proofwarden slam attack telegraphed with windup (shield flashes)
15. Proofwarden slam recovery leaves it vulnerable (shield down)
16. Player takes damage on enemy contact (invincibility flash activates)
17. Player invincibility prevents damage during i-frames
18. Dash i-frames prevent contact damage
19. Player health HUD displays correctly (hearts at screen top)
20. All enemy params tunable via debug sliders

**Keyboard Controls:**
| Key | Action |
|-----|--------|
| Arrow Left/Right | Move |
| Arrow Up / Z / Space | Jump |
| Arrow Down | Crouch |
| X / Shift | Dash |
| J / Enter | Attack (with current weapon) |
| K | Switch weapon |
| D | Toggle debug overlays |

### 8. Visual Design

**Reader:**
- Body: Small red rectangle (`#ef4444`). Slightly wider than tall (20×24).
- Patrol: bobs up and down 2px while walking.
- Chase: body tilts forward slightly (draw with slight skew transform).
- Lunge: streak effect — trail of 3-4 afterimages fading behind it.
- Hit: white flash, ink particles in warm reds.
- Death: bursts into red/orange ink splatter particles (10-15 particles).

**Binder:**
- Body: Purple rectangle (`#a855f7`). Wider build (28×36).
- Idle: slight pulsing scale animation (scaleX oscillates 0.95–1.05).
- Thread: 2px line, `#7c3aed`, with small node at the tip.
- Targeting (windup): dashed line `#7c3aed44` from center to player, pulses opacity.
- Pull active: thread thickens to 3px, glows brighter, small particles along the thread.
- Thread break (dash escape): thread snaps with 6-8 purple particles at break point.
- Hit: white flash, purple ink particles.
- Death: purple ink splatter.

**Proofwarden:**
- Body: Amber rectangle (`#f59e0b`). Large (32×40).
- Shield: thick arc drawn on front side using `ctx.arc()`. Color: `#fbbf24` with `#ffffff` edge (2px stroke). Arc spans `shieldBlockAngle` degrees centered on facing direction.
- Patrol: heavy, deliberate movement. No bobbing (feels solid).
- Slam windup: shield flashes white at increasing frequency. Body raises (scaleY 1.0→1.1).
- Slam active: body drops (scaleY 1.1→0.85), slam hitbox flashes bright amber.
- Slam recovery: shield disappears, body color dims to `#d97706` (darker amber), slight wobble.
- Shield block: burst of yellow/white spark particles (6-8), small screen shake (intensity 1.5, 2 frames).
- Hit (unshielded): white flash, amber ink particles.
- Death: amber ink splatter, shield fragments (additional angular particles).

**Player damage feedback:**
- On taking damage: player flashes red for 4 frames, then blinks (toggle alpha every 4 frames) during invincibility.
- Health HUD: Row of heart icons at top-center of screen. Filled heart = `#ef4444`, empty heart outline = `#4b5563`. Each heart is 16×16 with 4px spacing. Use simple canvas drawing (no sprites needed — draw heart shape with `ctx.beginPath()` + arcs + lineTo, or just use colored squares with a + shape for simplicity).

## Files to Create

- `src/engine/entities/Enemy.ts` — Abstract enemy base class
- `src/engine/entities/enemies/Reader.ts` — Reader rush enemy
- `src/engine/entities/enemies/Binder.ts` — Binder grapple enemy
- `src/engine/entities/enemies/Proofwarden.ts` — Proofwarden shield enemy
- `src/engine/entities/enemies/EnemyParams.ts` — All enemy param interfaces and defaults
- `src/engine/combat/PlayerHealth.ts` — Player health/damage overlay system

## Files to Modify

- `src/engine/entities/index.ts` — Export Enemy, Reader, Binder, Proofwarden
- `src/engine/combat/index.ts` — Export PlayerHealth
- `src/app/test/enemies/page.tsx` — Full test page (replace stub)
- `src/lib/testStatus.ts` — Update enemies status to `'in-progress'`

## Important Implementation Notes

1. **Enemies do NOT modify the Player class.** Enemies are decoupled from the player. They read `playerRef` for position/state information. Damage to the player is handled by `PlayerHealth` in the test page. Thread pull is handled by exposing `pullForce` and letting the test page apply it. This is the same decoupled pattern as CombatSystem and abilities.

2. **Enemy collision with TileMap.** Enemies use the exact same `tileMap.resolveCollisions()` call as the player. This gives them proper platform collision, gravity, and grounded detection. The TileMap doesn't care what kind of entity it's resolving — it just needs `{ position, velocity, size }`.

3. **Ledge detection for Readers.** Before moving, probe 1px below + 1px ahead of the leading edge: create a small rect `{ x: position.x + (facingRight ? size.x + 1 : -2), y: position.y + size.y + 1, width: 1, height: 1 }`. Check if any platform in the TileMap contains this point. If not, there's a ledge ahead. Add a `hasGroundAhead(direction: number): boolean` method to the Enemy base class or to TileMap.

4. **Contact damage check in test page update callback.** Each frame, iterate over all alive enemies. For enemies in aggressive states (Reader CHASE/ATTACK, Binder with active thread, Proofwarden SLAM_ACTIVE), check if enemy bounds overlap player bounds. If yes and `playerHealth.canTakeDamage(...)`, apply damage. Use `aabbOverlap()` from `src/engine/physics/AABB.ts`.

5. **Binder pull force application.** The Binder exposes `pullForce: Vec2 | null`. The test page reads it: `if (binder.pullForce) { player.velocity.x += binder.pullForce.x * dt * 60; player.velocity.y += binder.pullForce.y * dt * 60; }`. Multiply by `dt * 60` to make it frame-rate independent. The player can fight against the pull with movement input.

6. **Proofwarden shield block check.** Override `takeDamage()` in Proofwarden. Before applying damage, check if the attack came from the shielded direction. Compute: `attackAngle = atan2(hitbox.center.y - this.center.y, hitbox.center.x - this.center.x)`. Compare to `shieldAngle = facingRight ? 0 : Math.PI`. If `|angleDiff| < shieldBlockAngle / 2 * DEG2RAD` AND shield is active (not in SLAM_RECOVERY), block the hit. Return false from `takeDamage()` and play block effects.

7. **Wire CombatSystem hit detection to enemies.** In the test page update callback, after `combatSystem.update()`, call `combatSystem.checkHits()` with ALL alive enemies (Readers + Binders + Proofwardens). The combat system produces hitboxes from the player's attacks; this check applies them to enemies.

8. **Enemy rendering order.** Enemies render via the EntityManager which calls `entity.render()` for each. Detection ranges, health bars, and state labels render in the debug layer (after entities). Thread lines render in the `fx` layer (between entities and debug).

9. **Camera follows player only.** The camera tracks the player as usual. Enemies off-screen still run their AI (they don't despawn). The level is 2880px wide so the camera scrolls horizontally.

10. **All enemies share ParticleSystem and ScreenShake.** Pass the same instances to all enemies. This keeps the particle count manageable (max 200 shared).

11. **Reader lunge commits.** During the ATTACK state, the Reader ignores ledge detection and moves at `lungeSpeed` in its facing direction. If it lunges off a platform, it falls (gravity applies normally). This makes the lunge feel committed and punishable — the Reader can overshoot.

12. **Binder is mostly stationary.** Unlike Reader and Proofwarden, the Binder does not patrol or chase. It stays on its platform and attacks from range with the thread. This creates a distinct tactical challenge — you need to close distance to fight it, but it's trying to pull you into a bad position.

## Design Decisions (Pre-settled)

1. **Three distinct archetypes, not variations.** Each enemy plays completely differently. Reader tests reflexes, Binder tests positioning, Proofwarden tests puzzle-solving. This is more interesting than 3 enemies that all just rush at you.

2. **Player health is 5 hearts.** Generous — the test page is for tuning enemies, not for difficulty. Player can toggle invincibility in debug panel if needed.

3. **All enemies respawn in test page.** Respawn delay: 180 frames (3 seconds). This lets the player keep testing without reloading.

4. **Enemy AI runs even off-screen.** Enemies don't despawn when off camera. Their patrol and detection continues. If a Reader detects the player from off-screen, it starts chasing.

5. **No enemy-enemy collision.** Enemies pass through each other. Simplifies the physics significantly and avoids crowding issues. They only collide with the TileMap and the player.

6. **Binder pull is a force, not a teleport.** The player can resist the pull with movement input. Dash breaks it instantly. This keeps the player feeling in control even when caught.

7. **Proofwarden slam is highly telegraphed.** 25 frames (417ms) of windup is enough for the player to react and get behind. The recovery (40 frames = 667ms) is long enough to get 2-3 spear hits in. This teaches the player the rhythm: dodge slam → punish from behind → repeat.

8. **Contact damage from all enemies.** Even the Binder deals 1 contact damage if the player touches it. This prevents the player from just standing inside enemies.

## Verification

- [ ] `npx tsc --noEmit` passes with zero errors
- [ ] `npm run build` succeeds
- [ ] Navigate to `/test/enemies` — canvas renders with 3 arenas, player, 9 enemies
- [ ] Readers patrol back and forth on platforms, reverse at ledges
- [ ] Reader detects player within range, switches to chase (state label changes)
- [ ] Reader lunges at player, deals contact damage (player health decreases)
- [ ] Player can kill Readers with spear attacks (2 hits)
- [ ] Readers show knockback/hitstop on hit
- [ ] Dead Readers respawn after 3 seconds
- [ ] Binders fire thread toward player (visible line extends from Binder)
- [ ] Thread connecting to player pulls player toward Binder (player slides)
- [ ] Player can dash to break Binder thread (thread snaps)
- [ ] Binder can be damaged with spear/snap attacks
- [ ] Proofwarden shield blocks frontal attacks (no damage, sparks effect)
- [ ] Proofwarden can be hit from behind or above (damage applies)
- [ ] Proofwarden slam has clear windup telegraph
- [ ] Proofwarden slam deals damage to player in hitbox area
- [ ] Proofwarden is vulnerable during slam recovery (shield down)
- [ ] Player invincibility frames work (brief flash, no damage during i-frames)
- [ ] Dash i-frames prevent contact damage
- [ ] Player health HUD shows hearts at top of screen
- [ ] All enemy params tunable via debug sliders
- [ ] All existing movement + combat works exactly as before (no regressions)
- [ ] FPS stays at ~60fps with all 9 enemies active
- [ ] Respawn all / reset buttons work

---

## Implementation Summary

### Files Created (8)
- `src/engine/entities/Enemy.ts` — Abstract enemy base class extending Entity, implementing Damageable. Provides updateBase() (hitstop → death/respawn → timers → hitstun knockback → AI → gravity → integrate → collisions) and renderBase() (body, health bar, state label, hit flash, hitstop glow).
- `src/engine/entities/enemies/EnemyParams.ts` — ReaderParams, BinderParams, ProofwardenParams interfaces with DEFAULT_* constants. All tunable enemy values centralized for debug panel access.
- `src/engine/entities/enemies/Reader.ts` — Fast rush enemy. States: PATROL, CHASE, ATTACK, RECOVER, HURT, DEAD. Patrol with ledge detection, lunge attack that commits (ignores ledges), afterimage trail during lunge.
- `src/engine/entities/enemies/Binder.ts` — Stationary grapple enemy. States: IDLE, WINDUP, THREAD_FIRE, PULLING, THREAD_RETRACT, HURT, DEAD. Thread fires toward player position at fire time (not tracking). Exposes pullForce for test page to apply to player. Thread breaks when player dashes.
- `src/engine/entities/enemies/Proofwarden.ts` — Shield+slam enemy. States: PATROL, CHASE, SLAM_WINDUP, SLAM_ACTIVE, SLAM_RECOVERY, HURT, DEAD. Frontal shield blocks attacks from shielded side. Shield disabled during SLAM_RECOVERY (punish window). Slam hitbox rect in front during SLAM_ACTIVE.
- `src/engine/combat/PlayerHealth.ts` — Player health/damage overlay system with i-frames, knockback, HUD hearts rendering at top-center of screen.
- `src/app/test/enemies/page.tsx` — Full test page with 3 arenas (Reader Rush, Binder Trap, Proofwarden Gauntlet). 9 enemies total, camera follows player, debug panel with param sliders, pass criteria auto-detection.

### Files Modified (2)
- `src/engine/entities/index.ts` — Added exports for Enemy, EnemyConfig, PlayerRef, Reader, Binder, Proofwarden, and all param types/defaults.
- `src/engine/combat/index.ts` — Added exports for PlayerHealth, DEFAULT_PLAYER_HEALTH_PARAMS, PlayerHealthParams.
- `src/lib/testStatus.ts` — Changed enemies status from "not-started" to "in-progress".

### Architecture Decisions
- Enemy base class uses `abstract stateMachine: StateMachine<any>` due to TypeScript generic covariance issues with `StateMachine<Reader>` vs `StateMachine<Binder>` etc.
- PlayerRef interface provides a minimal subset of Player properties for enemy AI, keeping enemies decoupled from the full Player class.
- Proofwarden shield uses simplified directional check (knockback direction implies attack source direction) rather than full angular computation.
- Binder exposes `pullForce: Vec2 | null` rather than directly modifying player — test page reads and applies to player velocity.
- PlayerHealth is a separate overlay system, not part of Player class, following the same pattern as CombatSystem.

### Verification
- `npx tsc --noEmit` — passes clean (0 errors)
- `npm run build` — production build succeeds, all 27 routes generated

---

## Review Notes (Reviewer: 3b50139b)

### Issues Found and Fixed (3)

**1. Reader PATROL bob animation was invisible** (`src/engine/entities/enemies/Reader.ts`)
- The `render()` method computed a bob offset on a local `pos` variable during PATROL state, but then called `renderBase()` which re-computed its own interpolated position, discarding the bob offset.
- **Fix:** Added manual rendering for the PATROL state (body + health bar), matching the CHASE state's manual rendering pattern, so the bob offset is actually visible.

**2. Proofwarden shield block used 180° check instead of `shieldBlockAngle`** (`src/engine/entities/enemies/Proofwarden.ts`)
- The `takeDamage()` shield check used a simplified left/right directional test (`knockback.x < 0`), effectively creating a 180° block arc regardless of the `shieldBlockAngle` parameter (default 120°). This meant the shield was more powerful than intended — attacks from ~150° still got blocked when they should have bypassed a 120° shield.
- **Fix:** Replaced the simplified check with proper angular math using `Math.atan2` on the knockback direction and comparing the angular difference to `shieldBlockAngle / 2 * DEG2RAD`. The `DEG2RAD` constant was already defined but unused in `takeDamage`.

**3. Binder `threadDamage` param was never applied** (`src/engine/entities/enemies/Binder.ts`, `src/app/test/enemies/page.tsx`)
- The spec says the Binder deals `threadDamage` (1 hp) when the thread connects to the player. The `threadDamage` param existed in `EnemyParams.ts` with a debug slider, but was never actually applied — the Binder only dealt contact damage on body overlap.
- **Fix:** Added a `threadJustConnected` flag on the Binder, set when entering PULLING state and cleared at the start of each update. The test page now checks this flag and applies `threadDamage` via `PlayerHealth.takeDamage()`.

### Items Reviewed (no issues found)
- **Enemy.ts base class:** updateBase() sequence correct (hitstop → death → timers → hitstun → AI → gravity → integrate → collisions). Knockback friction (0.92) is frame-count based, which is correct for 60Hz fixed timestep.
- **EnemyParams.ts:** All three param interfaces match the spec. Defaults correct.
- **Reader.ts:** State machine complete (6 states). Ledge detection correct. Lunge commits (ignores ledges). Hysteresis on chase→patrol transition. Afterimage trail fades correctly.
- **Binder.ts:** Thread fires at snapshot position (not tracking). Pull force exposed correctly for decoupled application. Thread breaks on player dash. Cooldown after hurt.
- **Proofwarden.ts:** Slam windup telegraph, active hitbox, recovery window all correct. Shield disabled during SLAM_RECOVERY. Death particles + shield fragment particles.
- **PlayerHealth.ts:** I-frames, dash i-frames, knockback with decay. HUD hearts render at screen center.
- **Test page:** 3 arenas, 9 enemies. Camera follows player. All 20 pass criteria wired. Debug sliders for all params. Control buttons for respawn/reset/toggle. Contact damage checks after enemy updates. No memory leaks (engine.stop() on unmount).
- **Exports:** All types and classes properly exported from index files.

### Post-fix verification
- `npx tsc --noEmit` — passes clean (0 errors)
- `npm run build` — production build succeeds
