# Task: Melee Combat — Quill-Spear & Ink Snap Weapons

## Overview

Implement the **melee combat system** and its test page (`/test/combat-melee`). This is Phase 3, step 13 — the first combat task. It introduces two weapons: the **quill-spear** (fast mid-range directional attack) and the **ink snap** (short range auto-aim burst). It also establishes the core combat infrastructure: attack hitboxes, hit detection, damage/knockback, hitstop, and target dummies.

**The single most important design principle:** combat must have **zero flow interruption**. The player NEVER stops moving to attack. Attacks overlay on top of movement — the player can swing the quill-spear while running, jumping, wall-sliding, dashing, or crouching. Combat is a parallel system, not a player state.

**Dependencies:**
- Phase 1 movement system complete ✅ (player state machine, physics, collision)
- Entity system complete ✅ (base class for enemies/dummies)
- Input system complete ✅ (`InputAction.Attack` already mapped to `j`/`Enter`)
- Particle system and screen shake complete ✅ (for hit effects)
- Phase 2 abilities are NOT a dependency — combat is independent of editing abilities

## Critical Design Decision: Combat as Overlay, Not State

Traditional approach (WRONG for this game): add an `ATTACKING` state to the player state machine that blocks movement during the attack animation.

**Correct approach:** Combat is a **parallel system** that runs alongside the player state machine. The `CombatSystem` class tracks attack state (wind-up, active, recovery) independently. The player keeps running/jumping/dashing/wall-sliding while attacks happen. The attack hitbox position is computed relative to the player's position each frame, so it follows the player through movement.

This is the same pattern as abilities — abilities don't add player states, they operate on the world. Combat doesn't add player states, it produces hitboxes relative to the player.

The player state machine is NOT modified. No new states. No new transitions. The 10 existing states continue to work exactly as they do now.

## What to Build

### 1. Combat Types (`src/engine/combat/types.ts`)

```typescript
import type { Vec2, Rect } from "@/lib/types";

/** Direction an attack can be aimed */
export type AttackDirection = 'left' | 'right' | 'up' | 'down' | 'up-left' | 'up-right' | 'down-left' | 'down-right';

/** The phase of an attack's lifecycle */
export type AttackPhase = 'idle' | 'windup' | 'active' | 'recovery' | 'cooldown';

/** Which weapon is being used */
export type WeaponType = 'quill-spear' | 'ink-snap';

/** A hitbox produced by an attack */
export interface AttackHitbox {
  /** World-space rectangle of the hitbox */
  rect: Rect;
  /** Damage dealt on hit */
  damage: number;
  /** Knockback impulse applied to the target on hit */
  knockback: Vec2;
  /** Which weapon produced this hitbox */
  weapon: WeaponType;
  /** Attack direction (for visual effects) */
  direction: AttackDirection;
  /** Set of entity IDs already hit by this attack (prevent multi-hit per swing) */
  hitEntities: Set<string>;
}

/** Result of a hit check */
export interface HitResult {
  /** The entity that was hit */
  targetId: string;
  /** The hitbox that hit it */
  hitbox: AttackHitbox;
  /** World-space position of the hit (center of overlap) */
  hitPosition: Vec2;
  /** Knockback to apply */
  knockback: Vec2;
  /** Damage dealt */
  damage: number;
}

/** Health component — mixable into any entity that can take damage */
export interface Damageable {
  health: number;
  maxHealth: number;
  knockbackVelocity: Vec2;
  hitstunFrames: number;
  invincibilityFrames: number;
  isAlive: boolean;
}
```

### 2. Combat Parameters (`src/engine/combat/CombatParams.ts`)

```typescript
export interface CombatParams {
  // === Quill-Spear ===
  /** Frames of wind-up before the hitbox becomes active */
  spearWindupFrames: number;
  /** Frames the spear hitbox is active */
  spearActiveFrames: number;
  /** Frames of recovery after the active phase */
  spearRecoveryFrames: number;
  /** Cooldown frames before the next spear attack */
  spearCooldownFrames: number;
  /** Width of the spear hitbox (extends from player center) */
  spearReach: number;
  /** Height of the spear hitbox */
  spearWidth: number;
  /** Damage per hit */
  spearDamage: number;
  /** Knockback speed applied to target */
  spearKnockback: number;
  /** Duration of hitstop (target-only freeze) in frames */
  spearHitstopFrames: number;
  /** Screen shake intensity on hit */
  spearShakeIntensity: number;
  /** Screen shake duration in frames */
  spearShakeFrames: number;

  // === Ink Snap ===
  /** Frames of wind-up before the snap fires */
  snapWindupFrames: number;
  /** Frames the snap hitbox is active */
  snapActiveFrames: number;
  /** Frames of recovery after the active phase */
  snapRecoveryFrames: number;
  /** Cooldown frames before the next snap */
  snapCooldownFrames: number;
  /** Radius of the snap area of effect */
  snapRadius: number;
  /** Auto-aim range — how far away the snap can target an enemy */
  snapAutoAimRange: number;
  /** Damage per hit */
  snapDamage: number;
  /** Knockback speed applied to target (outward from snap center) */
  snapKnockback: number;
  /** Hitstop frames on target */
  snapHitstopFrames: number;
  /** Screen shake intensity on hit */
  snapShakeIntensity: number;
  /** Screen shake duration in frames */
  snapShakeFrames: number;

  // === General ===
  /** Whether the player can attack during dash */
  attackDuringDash: boolean;
  /** Whether the player can attack while wall-sliding */
  attackDuringWallSlide: boolean;
  /** Whether the player can attack while in hard landing recovery */
  attackDuringHardLanding: boolean;
}

export const DEFAULT_COMBAT_PARAMS: CombatParams = {
  // Quill-Spear: fast, mid-range, directional
  spearWindupFrames: 2,         // Near-instant — 2 frames = 33ms
  spearActiveFrames: 4,         // Short active window — 4 frames = 67ms
  spearRecoveryFrames: 3,       // Quick recovery — 3 frames = 50ms
  spearCooldownFrames: 6,       // Short cooldown — 6 frames = 100ms (allows rapid poking)
  spearReach: 48,               // 48px reach from player edge (mid-range)
  spearWidth: 16,               // 16px wide hitbox
  spearDamage: 1,               // 1 HP per hit
  spearKnockback: 250,          // Moderate knockback speed (px/s)
  spearHitstopFrames: 4,        // Brief hitstop on enemy (67ms)
  spearShakeIntensity: 2,       // Subtle screen shake
  spearShakeFrames: 3,          // Quick shake

  // Ink Snap: short-range, auto-aim, burst
  snapWindupFrames: 3,          // Slightly slower — 3 frames = 50ms
  snapActiveFrames: 3,          // Brief burst — 3 frames = 50ms
  snapRadius: 28,               // 28px radius (short range)
  snapAutoAimRange: 120,        // Auto-targets enemies within 120px
  snapRecoveryFrames: 4,        // 4 frames = 67ms recovery
  snapCooldownFrames: 12,       // Longer cooldown — 12 frames = 200ms
  snapDamage: 2,                // Higher damage (risk/reward — must be close)
  snapKnockback: 400,           // Stronger knockback (point-blank punch)
  snapHitstopFrames: 6,         // Longer hitstop (more impact feel)
  snapShakeIntensity: 4,        // More shake (bigger hit)
  snapShakeFrames: 4,           // Slightly longer shake

  // General
  attackDuringDash: true,       // Yes — zero interruption means everywhere
  attackDuringWallSlide: true,
  attackDuringHardLanding: false, // Exception: hard landing locks out attacks too
};
```

### 3. Combat System (`src/engine/combat/CombatSystem.ts`)

The core combat controller. It tracks attack state, produces hitboxes, checks hits against targets, and applies damage/knockback/effects.

```typescript
export class CombatSystem {
  params: CombatParams;

  /** Current weapon state */
  currentWeapon: WeaponType | null = null;
  attackPhase: AttackPhase = 'idle';
  phaseTimer: number = 0;      // Frames remaining in current phase
  attackDirection: AttackDirection = 'right';

  /** Active hitbox (null when not in active phase) */
  activeHitbox: AttackHitbox | null = null;

  /** Cooldown timer (frames remaining) */
  cooldownTimer: number = 0;

  /** Auto-aim target for ink snap (entity ID) */
  snapTarget: string | null = null;

  /** Whether combat system is enabled */
  enabled: boolean = true;

  constructor(params?: Partial<CombatParams>);

  /**
   * Check if the player can attack right now.
   * Considers: current attack phase, cooldown, player state restrictions.
   */
  canAttack(playerState: string): boolean;

  /**
   * Start a quill-spear attack in the given direction.
   * Direction is determined from input (8-directional, defaults to facing direction).
   */
  startSpearAttack(direction: AttackDirection): void;

  /**
   * Start an ink-snap attack.
   * Auto-aims at nearest target within range. If no target, aims in facing direction.
   */
  startSnapAttack(targetPosition: Vec2 | null): void;

  /**
   * Main update — advance attack phase timers, produce/clear hitbox.
   * Call every fixed-timestep frame.
   */
  update(playerBounds: Rect, facingRight: boolean): void;

  /**
   * Compute the quill-spear hitbox position based on player position and attack direction.
   * The hitbox extends from the player's edge in the attack direction.
   */
  computeSpearHitbox(playerBounds: Rect): Rect;

  /**
   * Compute the ink-snap hitbox as a circle approximated by a square, centered on the target
   * or on the player if no target.
   */
  computeSnapHitbox(playerBounds: Rect, targetPosition: Vec2 | null): Rect;

  /**
   * Find the nearest damageable target within ink-snap auto-aim range.
   * Returns the target's center position, or null if none in range.
   */
  findSnapTarget(playerCenter: Vec2, targets: Array<{ id: string; bounds: Rect }>): { id: string; position: Vec2 } | null;

  /**
   * Check the active hitbox against a list of potential targets.
   * Returns all new hits (targets not already hit by this attack).
   */
  checkHits(targets: Array<{ id: string; bounds: Rect }>): HitResult[];

  /**
   * Render attack visuals: wind-up flash, active hitbox, recovery fade, hit effects.
   */
  render(ctx: CanvasRenderingContext2D, camera: Camera): void;

  /**
   * Reset combat state (e.g., when player dies/respawns).
   */
  reset(): void;
}
```

**Attack direction logic:**

For quill-spear, read directional input to determine 8-directional aim:
- If holding Up + Right → `'up-right'`
- If holding only Right (or no direction and facing right) → `'right'`
- If holding Down → `'down'`
- etc.

For ink-snap, the direction is auto-aimed at the nearest target. The player doesn't need to aim.

**Hitbox positioning for quill-spear (8 directions):**

| Direction | Hitbox offset from player center |
|-----------|----------------------------------|
| right | x: playerRight, y: playerCenterY - spearWidth/2, w: spearReach, h: spearWidth |
| left | x: playerLeft - spearReach, y: playerCenterY - spearWidth/2, w: spearReach, h: spearWidth |
| up | x: playerCenterX - spearWidth/2, y: playerTop - spearReach, w: spearWidth, h: spearReach |
| down | x: playerCenterX - spearWidth/2, y: playerBottom, w: spearWidth, h: spearReach |
| up-right | x: playerRight - 8, y: playerTop - spearReach * 0.7, w: spearReach * 0.7, h: spearReach * 0.7 |
| up-left | x: playerLeft - spearReach * 0.7 + 8, y: playerTop - spearReach * 0.7, w: spearReach * 0.7, h: spearReach * 0.7 |
| down-right | x: playerRight - 8, y: playerBottom, w: spearReach * 0.7, h: spearReach * 0.7 |
| down-left | x: playerLeft - spearReach * 0.7 + 8, y: playerBottom, w: spearReach * 0.7, h: spearReach * 0.7 |

Diagonal hitboxes are 0.7× the reach in each axis (approximating a 45° rotation).

**Ink snap hitbox:**
- If a target is in auto-aim range: hitbox is centered on the target
- If no target: hitbox is centered on the player's forward edge (spearReach * 0.5 distance from player center in facing direction)
- Hitbox is a square with side length = `snapRadius * 2`

### 4. Target Dummy Entity (`src/engine/combat/TargetDummy.ts`)

Simple enemy entity for testing combat. Does NOT have AI (that's the Enemies task). Just stands there, takes hits, shows damage/knockback, and respawns.

```typescript
export interface TargetDummyConfig {
  /** Starting position */
  position: Vec2;
  /** Health points */
  health: number;
  /** Color for rendering */
  color: string;
  /** Whether the dummy respawns after being killed */
  respawns: boolean;
  /** Frames before respawning */
  respawnDelay: number;
  /** Whether the dummy moves (walks back and forth) — for testing moving targets */
  patrol: boolean;
  /** Patrol range (pixels) — distance it walks from starting position */
  patrolRange: number;
  /** Patrol speed (px/s) */
  patrolSpeed: number;
}

export class TargetDummy extends Entity implements Damageable {
  health: number;
  maxHealth: number;
  knockbackVelocity: Vec2 = { x: 0, y: 0 };
  hitstunFrames: number = 0;
  invincibilityFrames: number = 0;
  isAlive: boolean = true;

  /** Spawn position for respawning */
  spawnPosition: Vec2;
  /** Whether it respawns */
  respawns: boolean;
  /** Respawn delay in frames */
  respawnDelay: number;
  /** Respawn timer (counts down when dead) */
  respawnTimer: number = 0;

  /** Patrol behavior */
  patrol: boolean;
  patrolRange: number;
  patrolSpeed: number;
  patrolDirection: number = 1;  // 1 or -1

  /** Hit flash timer (for visual feedback) */
  hitFlashTimer: number = 0;

  /** Hitstop: when > 0, the dummy freezes in place (player does NOT freeze) */
  hitstopTimer: number = 0;

  /** Total damage received (for display) */
  totalDamageReceived: number = 0;

  /** Gravity for knockback arcs */
  gravity: number = 980;

  /** Ground Y position (for landing after knockback) */
  groundY: number;

  /** Whether the dummy is grounded */
  grounded: boolean = true;

  constructor(config: TargetDummyConfig);

  /** Apply damage and knockback. Returns true if the dummy was hit. */
  takeDamage(damage: number, knockback: Vec2, hitstopFrames: number): boolean;

  /** Update: apply knockback physics, hitstun, gravity, respawn timer, patrol movement */
  update(dt: number): void;

  /** Render: colored rect with health bar, hit flash, damage numbers */
  render(renderer: Renderer, interpolation: number): void;

  /** Reset to spawn state */
  reset(): void;
}
```

**Target dummy behavior:**

- **Idle:** Stands still (or patrols back and forth if `patrol` is true)
- **Hit:** Flash white for 4 frames, apply knockback velocity, enter hitstun. During hitstop frames, the dummy freezes completely (position doesn't update). After hitstop, knockback plays out normally.
- **Knockback:** Apply knockback velocity with gravity. When the dummy lands back on the ground (y reaches groundY), knockback ends, small bounce.
- **Death:** When health <= 0, play death particles (ink splatter), become inactive. If respawns is true, count down respawnDelay then reset.
- **Respawn:** Fade in at spawn position, full health restored.

**Hitstop (enemy-only):**
This is key to the feel. When the quill-spear hits a dummy, the dummy freezes for `spearHitstopFrames` (4 frames). The player does NOT freeze — they keep moving. This creates a satisfying "impact" feeling where the enemy pauses on hit but the player flows through. After the hitstop, the knockback is applied to the dummy.

### 5. Weapon Switching

The player has two weapons. For the test page, use a simple toggle:

- **`j` / `Enter`** (Attack action) — attacks with the **currently selected weapon**
- **`k`** — switch weapon (toggle between quill-spear and ink-snap)

Add a new input action for weapon switching:

```typescript
// In InputManager.ts
WeaponSwitch: "weaponSwitch",

// In DEFAULT_KEY_MAP
k: InputAction.WeaponSwitch,
```

The test page debug panel shows which weapon is selected and allows clicking to switch.

### 6. Test Page (`/test/combat-melee`)

Replace the stub with a full test page.

**Test Level Layout (1920×540, 2× canvas width):**

The combat test level is smaller than the movement playground — combat doesn't need as much space. It focuses on testing attacks against targets in various positions and movement states.

```
┌═══════════════════════════════════════════════════════════════════════════════════┐
│                                                                                   │
│                              ┌────┐                                               │
│                              │ D5 │  (elevated dummy — test upward attacks)       │
│                     ┌────────┘    └─────────┐                                    │
│          ┌────┐     │    Platform            │                                   │
│          │ D3 │     │                        │     ┌────┐                         │
│    ┌─────┘    │     └──────┐        ┌───────┘     │ D6 │                         │
│    │ Platform │            │        │              │    │                         │
│    └──────────┘            │        │     ┌────────┘    │   Wall                  │
│                            │        │     │  Platform   │   ████                 │
│  START   D1    D2          │        │     └─────────────┘   ████ D7              │
│  ████                      │        │                       ████ (wall-slide     │
│                            │        │                       ████  attack test)   │
│═══════════════════════════════════════════════════════════════════════════════════│
└═══════════════════════════════════════════════════════════════════════════════════┘
```

**Target Dummies (7 total):**

| ID | Position | Config | Purpose |
|----|----------|--------|---------|
| D1 | (200, ground) | Static, 3 HP, respawns | Basic ground target |
| D2 | (350, ground) | Static, 3 HP, respawns | Second ground target (test hitting both) |
| D3 | (120, elevated platform) | Static, 5 HP, respawns | Elevated target — test up-attacks, jump-attacks |
| D4 | (500, ground) | Patrolling, 4 HP, patrol range 100px, respawns | Moving target |
| D5 | (600, high platform) | Static, 3 HP, respawns | High target — test aerial attacks |
| D6 | (900, mid platform) | Static, 5 HP, respawns | Mid-range platform target |
| D7 | (1100, wall) | Static, 3 HP, respawns, positioned against wall | Wall-slide attack target |

**Level Geometry:**
- Main ground floor: y=460, spanning full width (1920px)
- Left platform: x=80, y=360, width=160 (for D3)
- Center platforms: a staircase of 3 platforms at increasing heights (x: 450-700, y: 360, 280, 200) for testing attacks at various heights
- Right elevated platform: x=820, y=320, width=180 (for D6)
- Right wall: x=1050, full height (for D7 wall-slide attacks)
- Left boundary wall, right boundary wall, ceiling

**Detailed Platform Layout:**
```typescript
const platforms: Platform[] = [
  // Ground
  { x: 0, y: 460, width: 1920, height: 80 },
  // Left elevated platform (D3)
  { x: 80, y: 360, width: 160, height: 20 },
  // Center staircase
  { x: 400, y: 380, width: 120, height: 20 },
  { x: 540, y: 300, width: 140, height: 20 },
  { x: 690, y: 220, width: 120, height: 20 },   // D5 stands here
  // Right platform (D6)
  { x: 820, y: 320, width: 180, height: 20 },
  // Right wall (for wall-slide attacks)
  { x: 1060, y: 100, width: 40, height: 360 },
  // Boundaries
  { x: 0, y: 0, width: 1920, height: 20 },      // Ceiling
  { x: 0, y: 0, width: 20, height: 540 },        // Left wall
  { x: 1900, y: 0, width: 20, height: 540 },     // Right wall
];
```

**Debug Overlays (on canvas):**
- Player hitbox (cyan outline)
- Active attack hitbox (red outline when in wind-up, bright red filled when active, fading when in recovery)
- Target dummy hitboxes (green outlines)
- Health bars above each dummy (red bar)
- Knockback velocity vectors on dummies (amber arrows)
- Hitstun indicator (white flash on dummy)
- Hitstop indicator (freeze frames counter above dummy)
- Damage numbers floating up from hit position
- Weapon indicator next to player (small icon/label)
- Auto-aim line for ink snap (dashed line to target)
- Attack direction indicator (small arrow showing aim direction)
- FPS counter, player state, velocity

**Debug Panel Sections:**

1. **Combat Info** (always visible):
   - Current weapon: Quill-Spear / Ink Snap
   - Attack phase: IDLE / WINDUP / ACTIVE / RECOVERY / COOLDOWN
   - Phase timer (frames remaining)
   - Cooldown timer
   - Snap auto-aim target (ID or "none")
   - Total hits landed
   - Total damage dealt
   - Per-dummy status: HP, total damage taken, alive/dead

2. **Quill-Spear Params** (expanded):
   | Parameter | Min | Max | Step | Default |
   |-----------|-----|-----|------|---------|
   | Windup Frames | 0 | 10 | 1 | 2 |
   | Active Frames | 1 | 12 | 1 | 4 |
   | Recovery Frames | 0 | 10 | 1 | 3 |
   | Cooldown Frames | 0 | 30 | 1 | 6 |
   | Reach | 20 | 100 | 4 | 48 |
   | Width | 8 | 40 | 2 | 16 |
   | Damage | 1 | 10 | 1 | 1 |
   | Knockback | 50 | 600 | 25 | 250 |
   | Hitstop Frames | 0 | 12 | 1 | 4 |
   | Shake Intensity | 0 | 10 | 0.5 | 2 |
   | Shake Frames | 0 | 10 | 1 | 3 |

3. **Ink Snap Params** (expanded):
   | Parameter | Min | Max | Step | Default |
   |-----------|-----|-----|------|---------|
   | Windup Frames | 0 | 10 | 1 | 3 |
   | Active Frames | 1 | 10 | 1 | 3 |
   | Recovery Frames | 0 | 10 | 1 | 4 |
   | Cooldown Frames | 0 | 30 | 1 | 12 |
   | Radius | 12 | 60 | 4 | 28 |
   | Auto-Aim Range | 40 | 300 | 10 | 120 |
   | Damage | 1 | 10 | 1 | 2 |
   | Knockback | 100 | 800 | 25 | 400 |
   | Hitstop Frames | 0 | 12 | 1 | 6 |
   | Shake Intensity | 0 | 10 | 0.5 | 4 |
   | Shake Frames | 0 | 10 | 1 | 4 |

4. **General Combat Params** (collapsed):
   - Attack during dash: toggle (default: true)
   - Attack during wall-slide: toggle (default: true)
   - Attack during hard landing: toggle (default: false)

5. **Target Dummy Controls** (collapsed):
   - Respawn all button
   - Reset damage counters button
   - Dummy health: slider (1–20, default 3)
   - Patrol speed: slider (0–200, default 60)

6. **Player State** (collapsed):
   - Standard movement params, state, velocity, position

**Pass Criteria (display on page):**

1. Pressing Attack (J/Enter) starts a quill-spear attack (wind-up → active → recovery phases visible)
2. Spear hitbox appears extending from the player in the aimed direction
3. Spear hitbox follows the player through movement (moves with player)
4. Hitting a dummy deals damage (health bar decreases)
5. Dummy shows hitstop (freezes briefly on hit) — player does NOT freeze
6. Dummy receives knockback (launched away from hit) after hitstop ends
7. Screen shakes briefly on hit
8. Hit particles spawn at hit position
9. Attacking works during running (no speed loss, no animation pause)
10. Attacking works during jumping (in air, full air control maintained)
11. Attacking works during wall-sliding (stays on wall)
12. Attacking works during dashing (dash continues)
13. Attack direction follows directional input (8-directional aiming)
14. Switching weapons (K) changes to ink snap
15. Ink snap auto-aims at nearest enemy within range
16. Ink snap deals higher damage with stronger knockback than spear
17. Cooldown prevents attack spam (visible cooldown timer)
18. Dummy dies at 0 HP and respawns after delay
19. Floating damage numbers appear on hit
20. Multiple dummies can be fought without movement flow breaking

**Auto-detection for criteria:**
- 1: `attackPhase` changes from 'idle' to 'windup' on Attack press
- 2: `activeHitbox !== null` during active phase
- 3: hitbox world position changes when player moves during active phase
- 4: dummy health decreases after hit
- 5: dummy `hitstopTimer > 0` on hit AND player velocity is non-zero during hitstop
- 6: dummy `knockbackVelocity` magnitude > 0 after hitstop ends
- 7: `screenShake.isShaking()` returns true on hit
- 8: particle count increases on hit
- 9: player velocity.x magnitude > 0 during attack active phase while moving
- 10: player state is JUMPING or FALLING during attack active phase
- 11: player state is WALL_SLIDING during attack active phase
- 12: player state is DASHING during attack active phase
- 13: attack direction changes based on held input
- 14: `currentWeapon` changes on WeaponSwitch input
- 15: `snapTarget !== null` when enemy in range and using ink-snap
- 16: snap damage > spear damage (compare hit results)
- 17: attack fails when `cooldownTimer > 0`
- 18: dummy `isAlive` becomes false then true after respawnDelay
- 19: visual check (floating damage numbers rendered)
- 20: subjective feel check

**Keyboard Controls:**
| Key | Action |
|-----|--------|
| Arrow Left/Right | Move |
| Arrow Up / Z / Space | Jump |
| Arrow Down | Crouch |
| X / Shift | Dash |
| J / Enter | Attack (with current weapon) |
| K | Switch weapon (quill-spear ↔ ink snap) |
| D | Toggle debug overlays |

### 7. Visual Design

**Quill-Spear Attack Visuals:**
- **Wind-up (2 frames):** Small flash of white-blue at player's edge in attack direction. Player body shifts color slightly toward white.
- **Active (4 frames):** A bright rectangular hitbox rendered as a stylized spear thrust — narrow rectangle with pointed end. Color: `#60a5fa` (blue) with `#dbeafe` (light blue) edge. The hitbox shape should feel like a quick ink-pen thrust, not a sword swing. Draw it as a narrow tapered rect (wider at player, narrower at tip).
- **Recovery (3 frames):** The hitbox fades out (alpha decreasing over recovery frames). A faint ink trail lingers briefly.

**Ink Snap Attack Visuals:**
- **Wind-up (3 frames):** Dark ink particles gather toward the target position (or the player's forward edge).
- **Active (3 frames):** An ink burst — circular splash centered on the target. Color: `#1e1b4b` (deep indigo) burst with `#4338ca` (indigo) ring. Like an ink bottle smashed on the target.
- **Recovery (4 frames):** Ink droplets scatter outward, fading.

**Hit Effects:**
- On hit: burst of 8–12 ink particles from the hit position, in the direction of knockback
- Colors: mix of `#1e1b4b` (deep indigo), `#4338ca` (indigo), `#e0e7ff` (light indigo), `#ffffff` (white flash)
- Screen shake: brief, directional (biased in the knockback direction)
- Damage number: floats upward from hit position, white text, fades over 0.8s

**Dummy Visuals:**
- Body: colored rectangle (different color per dummy — use warm reds/oranges: `#ef4444`, `#f97316`, `#eab308`)
- Health bar: above the dummy, red bar on dark background, thin (3px high)
- Hit flash: body turns white for 3 frames on hit
- During hitstop: body has a bright outline (white or yellow glow)
- Death: ink splatter particles, body shrinks and fades
- Respawn: body fades in from transparent at spawn position

## Files to Create

- `src/engine/combat/types.ts` — Combat type definitions (AttackHitbox, HitResult, Damageable, AttackDirection, etc.)
- `src/engine/combat/CombatParams.ts` — CombatParams interface and DEFAULT_COMBAT_PARAMS
- `src/engine/combat/CombatSystem.ts` — Core combat controller (attack phases, hitbox production, hit detection)
- `src/engine/combat/TargetDummy.ts` — Target dummy entity for testing

## Files to Modify

- `src/engine/combat/index.ts` — Export all combat modules (replace empty export)
- `src/engine/input/InputManager.ts` — Add `WeaponSwitch` action, bind to `k` key
- `src/app/test/combat-melee/page.tsx` — Full test page (replace stub)
- `src/lib/testStatus.ts` — Update combat-melee status to `'in-progress'`

## Important Implementation Notes

1. **Combat does NOT modify the Player class or state machine.** This is critical. The CombatSystem is instantiated in the test page and wired in the `engine.onUpdate()` callback. It reads the player's position, facing, and input to produce hitboxes. It does NOT call `player.stateMachine.setState()` or add new states. The player is unaware of combat.

2. **Attack input handling in the test page update callback:**
   ```typescript
   // In engine.onUpdate():
   if (input.isPressed(InputAction.Attack) && combatSystem.canAttack(player.stateMachine.getCurrentState())) {
     if (combatSystem.currentWeapon === 'quill-spear' || combatSystem.currentWeapon === null) {
       const direction = getAttackDirection(input, player.facingRight);
       combatSystem.startSpearAttack(direction);
     } else {
       const targets = dummies.filter(d => d.isAlive).map(d => ({ id: d.id, bounds: d.getBounds() }));
       const autoAimTarget = combatSystem.findSnapTarget(playerCenter, targets);
       combatSystem.startSnapAttack(autoAimTarget?.position ?? null);
     }
   }
   if (input.isPressed(InputAction.WeaponSwitch)) {
     // Toggle weapon
   }
   combatSystem.update(player.getBounds(), player.facingRight);
   ```

3. **Hit detection in the test page update callback:**
   ```typescript
   const targets = dummies.filter(d => d.isAlive && d.invincibilityFrames <= 0)
     .map(d => ({ id: d.id, bounds: d.getBounds() }));
   const hits = combatSystem.checkHits(targets);
   for (const hit of hits) {
     const dummy = dummies.find(d => d.id === hit.targetId);
     if (dummy) {
       dummy.takeDamage(hit.damage, hit.knockback, hitbox.weapon === 'quill-spear'
         ? params.spearHitstopFrames : params.snapHitstopFrames);
       // Spawn particles, damage numbers, screen shake
     }
   }
   ```

4. **Hitstop is enemy-only.** When a hit lands, the dummy's `hitstopTimer` is set. During hitstop, the dummy's `update()` skips all position/velocity updates — it's frozen in place. The player's update is never affected. After hitstop expires, knockback velocity is applied and the dummy flies.

5. **Attack hitbox follows the player.** The hitbox is recomputed from the player's current position every frame during the active phase. It's not a projectile — it's attached to the player. If the player is running right and attacks right, the hitbox slides along with the player.

6. **Knockback direction.** For quill-spear: knockback direction matches the attack direction (with slight upward bias for horizontal attacks so dummies arc through the air: knockback.y = -knockback * 0.3 for horizontal hits). For ink-snap: knockback is outward from the snap center (snap position → dummy position vector, normalized, × knockback speed).

7. **Multiple hits per attack are prevented.** Each AttackHitbox has a `hitEntities: Set<string>`. Once an entity is hit by an attack, it's added to the set and won't be hit again by the same attack. A new attack (new press of Attack) creates a fresh hitbox with an empty set.

8. **Use the existing ParticleSystem and ScreenShake.** Create instances in the test page. Pass them to the combat system render calls for hit effects.

9. **Floating damage numbers are a simple screen-space overlay.** Track them as an array of `{ text: string, x: number, y: number, vy: number, alpha: number, timer: number }`. Each number floats upward and fades out over ~0.8 seconds. Render them in the `engine.onRender()` callback after the entities layer.

10. **`getAttackDirection()` helper function.** Reads directional input and player facing to produce an 8-directional attack direction:
    ```typescript
    function getAttackDirection(input: InputManager, facingRight: boolean): AttackDirection {
      const up = input.isHeld(InputAction.Up);
      const down = input.isHeld(InputAction.Down);
      const left = input.isHeld(InputAction.Left);
      const right = input.isHeld(InputAction.Right);

      if (up && right) return 'up-right';
      if (up && left) return 'up-left';
      if (down && right) return 'down-right';
      if (down && left) return 'down-left';
      if (up) return 'up';
      if (down) return 'down';
      if (right) return 'right';
      if (left) return 'left';
      return facingRight ? 'right' : 'left';  // Default to facing direction
    }
    ```

11. **Target dummy gravity and ground detection.** Dummies don't use the full TileMap collision system (they're simple). Instead, each dummy knows its `groundY` (the Y position of the floor it stands on). When knocked back, the dummy flies with gravity. When `position.y + size.y >= groundY`, it lands. This is simpler than wiring up full TileMap collision for dummies. For the elevated dummies (D3, D5, D6), `groundY` is set to the platform Y they stand on. If a dummy gets knocked off its platform, it falls to the main ground floor.

12. **The camera for this test page.** The level is 1920×540 (2× canvas width), so the camera follows the player horizontally with standard smooth follow. Use `camera.setBounds({ x: 0, y: 0, width: 1920, height: 540 })`.

## Design Decisions (Pre-settled)

1. **Two weapons, one Attack button.** K toggles between them. This keeps controls simple. In the full game, weapons may have separate bindings, but for the test page, toggle is cleaner.
2. **Near-zero commitment frames.** Total attack duration: spear = 2+4+3 = 9 frames (150ms), snap = 3+3+4 = 10 frames (167ms). These are lightning fast. The player barely notices the attack happening.
3. **Cooldown is per-weapon.** The cooldown only applies to the weapon that was just used. Switching weapons does NOT reset cooldown (no exploiting weapon swap to bypass cooldown).
4. **No combo system yet.** This task implements individual attacks only. Combos (hit chains, finishers) are future work if needed. The rapid cooldown of the spear (6 frames = 100ms) means you can attack very frequently, which feels like a natural combo.
5. **Target dummies, not real enemies.** Dummies don't fight back. They exist purely to receive damage and show knockback. Real enemy AI is the next task (`/test/enemies`).
6. **Damage numbers are simple floating text.** No fancy animation system. Just text + velocity + alpha fade.
7. **Ink snap auto-aim is "nearest enemy in range."** No priority system, no target switching. Just find the closest alive enemy within `snapAutoAimRange` pixels of the player's center. Simple is better for the test page.
8. **Knockback arcs upward on horizontal hits.** When the spear hits horizontally, the knockback has a -0.3× upward component. This makes dummies arc through the air on hit, which looks and feels much better than sliding along the ground.

## Verification

- [ ] `npx tsc --noEmit` passes with zero errors
- [ ] `npm run build` succeeds
- [ ] Navigate to `/test/combat-melee` — canvas renders with test level, player, and 7 target dummies
- [ ] Pressing J performs a quill-spear attack — hitbox appears and follows player
- [ ] Attack direction matches directional input (all 8 directions work)
- [ ] Hitting a dummy: damage applied, health bar decreases, hitstop on dummy, knockback after hitstop
- [ ] Player does NOT freeze during hitstop — player movement continues normally
- [ ] Screen shake on hit, ink particles at hit position
- [ ] Attacking while running: player speed unchanged, attack hitbox follows player
- [ ] Attacking while jumping: player stays in air, full air control, hitbox follows
- [ ] Attacking while wall-sliding: player stays on wall, attack hitbox extends from player
- [ ] Attacking while dashing: dash continues, hitbox appears during dash
- [ ] Pressing K switches to ink snap weapon
- [ ] Ink snap auto-aims at nearest enemy (auto-aim line visible in debug)
- [ ] Ink snap deals higher damage with stronger knockback
- [ ] Cooldown prevents rapid re-attack (timer visible in debug panel)
- [ ] Dummy dies at 0 HP (death particles), respawns after delay
- [ ] Floating damage numbers appear on hit and float upward
- [ ] All combat params tunable via sliders in debug panel
- [ ] Elevated dummies (D3, D5, D6) can be hit with upward attacks
- [ ] Wall dummy (D7) can be hit while wall-sliding
- [ ] Patrolling dummy (D4) can be hit while moving
- [ ] Debug overlays: attack hitbox, dummy hitboxes, health bars, knockback vectors
- [ ] All existing movement works exactly as before (no regressions)
- [ ] FPS stays at ~60fps
- [ ] Reset buttons work (respawn dummies, reset counters)

---

## Implementation Summary

### Files Created
- `src/engine/combat/types.ts` — Combat type definitions: AttackDirection (8-dir), AttackPhase, WeaponType, AttackHitbox, HitResult, Damageable interface
- `src/engine/combat/CombatParams.ts` — CombatParams interface with all tunable values + DEFAULT_COMBAT_PARAMS defaults
- `src/engine/combat/CombatSystem.ts` — Core combat controller: attack phases (idle→windup→active→recovery→cooldown), hitbox computation (8-directional spear, auto-aim snap), hit detection via AABB overlap, knockback calculation, debug rendering
- `src/engine/combat/TargetDummy.ts` — Target dummy entity: takes damage, hitstop freeze, knockback arcs with gravity, death/respawn, patrol, health bars, hit flash, debug overlays

### Files Modified
- `src/engine/combat/index.ts` — Updated from empty export to export all combat modules
- `src/engine/input/InputManager.ts` — Added `WeaponSwitch` action ("weaponSwitch") and `k` key binding
- `src/app/test/combat-melee/page.tsx` — Full test page replacing stub: 1920×540 level with 7 dummies, camera follow, combat system wired to engine update/render, floating damage numbers, particle hit effects, screen shake, debug overlays, full debug panel with sliders for all combat params
- `src/lib/testStatus.ts` — Updated combat-melee status to "in-progress"

### Key Design Decisions
- **Combat is a parallel overlay, NOT a player state.** CombatSystem runs alongside the player state machine. The player keeps moving during attacks. No new player states were added.
- **Hitstop is enemy-only.** When hit, the dummy freezes; the player never freezes. This creates satisfying impact feel while maintaining flow.
- **Hitbox follows the player.** The attack hitbox is recomputed from the player's position every frame during the active phase, tracking the player through movement.
- **Knockback arcs upward.** Horizontal spear hits add a -0.3× upward knockback component, making dummies arc through the air on hit.
- **Multi-hit prevention.** Each AttackHitbox tracks hit entities in a Set to prevent hitting the same entity multiple times per swing.

### Verification
- `npx tsc --noEmit` — passes with zero errors
- `npm run build` — succeeds, all routes compile

---

## Review Notes (Reviewer: 5fe96c68)

### Fixes Applied

1. **`CombatSystem.ts` — `startSnapAttack()` now sets `attackDirection` from `facingRight`.**
   The snap attack did not set `attackDirection`, so the no-target snap hitbox fallback (`computeSnapHitbox` when `targetPosition` is null) used a stale direction from the previous spear attack. Added `facingRight` parameter to `startSnapAttack()` and set `this.attackDirection` accordingly. Updated the test page call site to pass `player.facingRight`.

### Issues Noted (No Fix Required)

- **`render()` windup block is dead code.** The `if (this.activeHitbox)` check inside the windup case (line ~401) can never be true since `activeHitbox` is null during windup. Harmless dead code — no functional impact.
- **`render()` receives `camera` param but doesn't use it.** The camera transform is already applied by the engine before calling the world-space render callback, so world coordinates are correct. The unused parameter is harmless.
- **Debug panel "Combat Info" shows stale React state.** The combat info section reads `combatRef.current` at React render time, so values only update when the component re-renders (e.g., slider changes). Real-time combat diagnostics are correctly shown on the canvas overlay instead. This matches the pattern of other test pages.
- **`TargetDummy` knockback friction (`KNOCKBACK_FRICTION = 0.95`) is per-frame, not `dt`-scaled.** With the fixed 60Hz timestep this is deterministic and correct. If the game ever moved to a variable timestep, this would need adjustment.
- **Phase timer off-by-one: `windupFrames=2` results in ~1 frame of effective windup** due to the decrement-then-check pattern consuming one tick on the frame of attack initiation. This is consistent across all phases and matches common fighting game patterns. The slider lets designers tune to the desired feel.
- **Pre-existing type errors in enemy files** (Binder, Proofwarden, Reader) — these are from another task, not introduced by the combat-melee implementation.

### Overall Assessment

Implementation is solid. The combat-as-overlay pattern is correctly implemented — no player state machine modifications. Fixed timestep is respected throughout. All params are wired to sliders. Hit detection, hitstop, knockback arcs, and multi-hit prevention are correct. The one fix applied (snap attack direction) is minor but prevents potentially confusing behavior in the edge case where ink-snap is used with no target in range.
