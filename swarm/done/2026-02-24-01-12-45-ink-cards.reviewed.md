# Task: Ink Cards — Crafting System with Stat Modifications

## Overview

Implement the **Ink Cards crafting system** and its test page (`/test/ink-cards`). This is Phase 4, step 18. It introduces the game's itemization and build-customization layer.

Ink Cards are the player's way of tailoring their stats — movement speed, jump height, damage output, defense, and ability parameters. Cards are collected, equipped to a limited deck, and can be crafted (combined) to produce stronger variants. The system provides meaningful build variety while staying simple enough to understand at a glance.

**Thematic flavor:** Ink Cards are vellum cards with handwritten inscriptions. Each card has an ink color (tied to its stat category), a glyph symbol, and a tier mark. They look like marginalia torn from enchanted manuscripts.

**This task has NO dependency on Herbarium Folio, Day/Night Cycle, or bosses.** It depends only on Phase 1 movement, combat system, and player health — all complete. The test page demonstrates cards modifying player stats in real time.

## Dependencies

- PlayerParams / DEFAULT_PLAYER_PARAMS ✅ (`src/engine/entities/Player.ts`)
- CombatParams / DEFAULT_COMBAT_PARAMS ✅ (`src/engine/combat/CombatParams.ts`)
- PlayerHealthParams / DEFAULT_PLAYER_HEALTH_PARAMS ✅ (`src/engine/combat/PlayerHealth.ts`)
- Player entity ✅
- CombatSystem ✅
- GameCanvas, DebugPanel, Slider components ✅
- Engine core (game loop, renderer, input) ✅

## What to Build

### 1. Ink Card Data Model (`src/engine/cards/InkCard.ts`)

```typescript
/** Card stat categories — each category modifies a group of related stats */
export type CardCategory = 'swiftness' | 'might' | 'resilience' | 'precision' | 'arcana';

/** Card tier — higher tier = stronger effect */
export type CardTier = 1 | 2 | 3;

/** Individual stat that a card can modify */
export type CardStat =
  // Swiftness (movement)
  | 'maxRunSpeed'
  | 'jumpSpeed'
  | 'dashSpeed'
  | 'airAcceleration'
  | 'dashCooldownReduction'   // Reduces dash cooldown frames (subtractive)
  // Might (combat offense)
  | 'spearDamage'
  | 'snapDamage'
  | 'spearReach'
  | 'snapRadius'
  | 'attackSpeedBoost'        // Reduces windup/recovery frames (multiplicative)
  // Resilience (defense)
  | 'maxHealth'
  | 'invincibilityFrames'
  | 'knockbackResistance'     // Reduces knockback speed received (multiplicative)
  // Precision (technique)
  | 'coyoteFrames'
  | 'jumpBufferFrames'
  | 'wallJumpHorizontalSpeed'
  | 'wallSlideGripSpeed'
  // Arcana (ability)
  | 'abilityCooldownReduction'  // Reduces ability cooldown (multiplicative)
  | 'abilityDurationBoost'      // Extends ability durations (multiplicative)
  | 'abilityRangeBoost';        // Extends ability ranges (multiplicative)

/** How the stat modification is applied */
export type ModifierType = 'additive' | 'multiplicative';

/** A single stat modification provided by a card */
export interface StatModifier {
  stat: CardStat;
  modifierType: ModifierType;
  value: number;  // For additive: raw amount. For multiplicative: 1.0 = no change, 1.2 = +20%
}

/** An Ink Card instance */
export interface InkCard {
  /** Unique ID for this card instance */
  id: string;
  /** Display name */
  name: string;
  /** Category — determines the card's ink color */
  category: CardCategory;
  /** Tier — determines effect magnitude */
  tier: CardTier;
  /** Glyph symbol for display */
  glyph: string;
  /** Short description of what the card does */
  description: string;
  /** Stat modifiers this card provides when equipped */
  modifiers: StatModifier[];
}

/** The player's card collection and equipped deck */
export interface CardDeck {
  /** All cards the player owns */
  collection: InkCard[];
  /** Currently equipped card IDs (limited to maxEquipped) */
  equippedIds: string[];
  /** Maximum number of cards that can be equipped at once */
  maxEquipped: number;
}
```

**Category colors (for rendering):**
| Category | Color | Hex | Glyph Examples |
|----------|-------|-----|----------------|
| Swiftness | Teal/Cyan | `#22d3ee` | ᚡ ᚢ ᚣ (wind runes) |
| Might | Red/Amber | `#f59e0b` | ᚴ ᚵ ᚶ (fire runes) |
| Resilience | Green | `#4ade80` | ᛞ ᛟ ᛠ (shield runes) |
| Precision | Purple | `#a78bfa` | ᛣ ᛤ ᛥ (eye runes) |
| Arcana | Indigo/Blue | `#6366f1` | ᛦ ᛧ ᛨ (star runes) |

### 2. Card Definitions (`src/engine/cards/CardDefinitions.ts`)

A catalog of all possible Ink Cards. Each category has 3-4 card types, each with 3 tiers.

```typescript
/** All card definitions organized by category */

// === SWIFTNESS ===
// Swift Strider (maxRunSpeed)
//   Tier 1: +20 maxRunSpeed
//   Tier 2: +40 maxRunSpeed
//   Tier 3: +60 maxRunSpeed
// Leap Glyph (jumpSpeed)
//   Tier 1: +25 jumpSpeed
//   Tier 2: +50 jumpSpeed
//   Tier 3: +75 jumpSpeed
// Dash Inscription (dashSpeed)
//   Tier 1: +40 dashSpeed, -1 dashCooldownReduction
//   Tier 2: +80 dashSpeed, -2 dashCooldownReduction
//   Tier 3: +120 dashSpeed, -4 dashCooldownReduction
// Air Script (airAcceleration)
//   Tier 1: +100 airAcceleration
//   Tier 2: +200 airAcceleration
//   Tier 3: +300 airAcceleration

// === MIGHT ===
// Spear Verse (spearDamage + spearReach)
//   Tier 1: +1 spearDamage
//   Tier 2: +1 spearDamage, +8 spearReach
//   Tier 3: +2 spearDamage, +12 spearReach
// Snap Verse (snapDamage + snapRadius)
//   Tier 1: +1 snapDamage
//   Tier 2: +1 snapDamage, +6 snapRadius
//   Tier 3: +2 snapDamage, +10 snapRadius
// Battle Tempo (attackSpeedBoost)
//   Tier 1: 0.9× attack frame multiplier (10% faster)
//   Tier 2: 0.8× attack frame multiplier (20% faster)
//   Tier 3: 0.7× attack frame multiplier (30% faster)

// === RESILIENCE ===
// Vellum Shield (maxHealth)
//   Tier 1: +1 maxHealth
//   Tier 2: +2 maxHealth
//   Tier 3: +3 maxHealth
// Ward Inscription (invincibilityFrames)
//   Tier 1: +10 invincibilityFrames
//   Tier 2: +20 invincibilityFrames
//   Tier 3: +30 invincibilityFrames
// Stoic Page (knockbackResistance)
//   Tier 1: 0.85× knockback received
//   Tier 2: 0.7× knockback received
//   Tier 3: 0.55× knockback received

// === PRECISION ===
// Ledge Reader (coyoteFrames + jumpBufferFrames)
//   Tier 1: +2 coyoteFrames, +1 jumpBufferFrames
//   Tier 2: +3 coyoteFrames, +2 jumpBufferFrames
//   Tier 3: +5 coyoteFrames, +3 jumpBufferFrames
// Wall Binding (wallJumpHorizontalSpeed + wallSlideGripSpeed)
//   Tier 1: +20 wallJumpHorizontalSpeed, -10 wallSlideGripSpeed (slower slide = more grip)
//   Tier 2: +40 wallJumpHorizontalSpeed, -15 wallSlideGripSpeed
//   Tier 3: +60 wallJumpHorizontalSpeed, -20 wallSlideGripSpeed

// === ARCANA ===
// Scribe's Haste (abilityCooldownReduction)
//   Tier 1: 0.9× ability cooldown
//   Tier 2: 0.8× ability cooldown
//   Tier 3: 0.7× ability cooldown
// Ink Well (abilityDurationBoost)
//   Tier 1: 1.15× ability duration
//   Tier 2: 1.3× ability duration
//   Tier 3: 1.5× ability duration
// Margin Expander (abilityRangeBoost)
//   Tier 1: 1.1× ability range
//   Tier 2: 1.2× ability range
//   Tier 3: 1.35× ability range
```

Implement as:
```typescript
export type CardDefinitionId = string;  // e.g., "swift-strider", "spear-verse"

export interface CardDefinition {
  id: CardDefinitionId;
  name: string;
  category: CardCategory;
  glyph: string;
  descriptionTemplate: string;  // Template with {tier} placeholder
  tiers: {
    [key in CardTier]: {
      description: string;
      modifiers: StatModifier[];
    };
  };
}

/** Create an InkCard instance from a definition + tier */
export function createCard(definitionId: CardDefinitionId, tier: CardTier): InkCard;

/** Get all card definitions */
export function getAllCardDefinitions(): CardDefinition[];

/** Get card definitions filtered by category */
export function getCardDefinitionsByCategory(category: CardCategory): CardDefinition[];

/** Complete catalog — 14 card definitions × 3 tiers = 42 possible cards */
export const CARD_DEFINITIONS: CardDefinition[];
```

### 3. Card Modifier Engine (`src/engine/cards/CardModifierEngine.ts`)

The core system that takes equipped cards and computes final stat modifiers.

```typescript
export interface ComputedModifiers {
  /** Additive modifiers by stat name: stat → total additive bonus */
  additive: Partial<Record<CardStat, number>>;
  /** Multiplicative modifiers by stat name: stat → total multiplier */
  multiplicative: Partial<Record<CardStat, number>>;
}

export interface CardModifierEngineParams {
  /** Maximum number of cards that can be equipped */
  maxEquipped: number;
  /** Whether duplicate card types are allowed (same definition, same tier) */
  allowDuplicates: boolean;
  /** Whether stacking the same stat from multiple cards has diminishing returns */
  diminishingReturns: boolean;
  /** Diminishing returns factor (e.g., 0.7 = second card of same stat gives 70% effect) */
  diminishingFactor: number;
  /** Hard caps for specific stats (prevent breaking the game) */
  statCaps: Partial<Record<CardStat, { min?: number; max?: number }>>;
}

export const DEFAULT_CARD_ENGINE_PARAMS: CardModifierEngineParams = {
  maxEquipped: 4,           // 4 card slots
  allowDuplicates: false,   // Can't equip two of the exact same card
  diminishingReturns: true, // Stacking same stat from different cards reduces effect
  diminishingFactor: 0.7,   // Second card's contribution to same stat = 70%
  statCaps: {
    maxRunSpeed: { max: 500 },          // Don't let speed go above 500
    jumpSpeed: { max: 600 },            // Cap jump height
    dashSpeed: { max: 900 },            // Cap dash speed
    spearDamage: { max: 5 },            // Cap weapon damage
    snapDamage: { max: 6 },
    maxHealth: { max: 10 },             // Cap health
    coyoteFrames: { max: 15 },          // Don't make coyote time absurd
    jumpBufferFrames: { max: 12 },
    attackSpeedBoost: { min: 0.5 },     // Can't reduce attack frames below 50%
    knockbackResistance: { min: 0.3 },  // Can't reduce knockback below 30%
    abilityCooldownReduction: { min: 0.5 }, // Can't reduce cooldown below 50%
  },
};

export class CardModifierEngine {
  params: CardModifierEngineParams;
  deck: CardDeck;

  constructor(params?: Partial<CardModifierEngineParams>);

  /**
   * Equip a card from the collection into an active slot.
   * Returns false if deck is full or card not in collection.
   */
  equipCard(cardId: string): boolean;

  /**
   * Unequip a card from the active deck.
   */
  unequipCard(cardId: string): void;

  /**
   * Add a card to the collection (from crafting or loot).
   */
  addToCollection(card: InkCard): void;

  /**
   * Remove a card from the collection (consumed in crafting).
   */
  removeFromCollection(cardId: string): void;

  /**
   * Compute the aggregate modifiers from all equipped cards.
   * Applies stacking rules, diminishing returns, and stat caps.
   */
  computeModifiers(): ComputedModifiers;

  /**
   * Apply computed modifiers to a PlayerParams object.
   * Returns a new params object with modifications applied.
   * Does NOT mutate the input.
   */
  applyToPlayerParams(baseParams: PlayerParams): PlayerParams;

  /**
   * Apply computed modifiers to a CombatParams object.
   * Returns a new params object with modifications applied.
   */
  applyToCombatParams(baseParams: CombatParams): CombatParams;

  /**
   * Apply computed modifiers to a PlayerHealthParams object.
   * Returns a new params object with modifications applied.
   */
  applyToHealthParams(baseParams: PlayerHealthParams): PlayerHealthParams;

  /**
   * Get a summary of all active modifiers for display in the UI.
   * Returns an array of human-readable stat change descriptions.
   */
  getModifierSummary(): ModifierSummaryEntry[];

  /** Get the current deck state */
  getDeck(): CardDeck;
}

export interface ModifierSummaryEntry {
  stat: CardStat;
  baseValue: number;
  modifiedValue: number;
  change: string;  // e.g., "+40" or "×0.8"
  sourceCards: string[];  // Names of cards contributing
}
```

**Stacking rules in detail:**

1. **Additive stats stack with diminishing returns.** If two cards both give `+20 maxRunSpeed`, the first gives full +20, the second gives +20 × 0.7 = +14, for a total of +34. A third would give +20 × 0.7² = +9.8, etc.

2. **Multiplicative stats multiply together (no diminishing returns on the multiplier itself, but there's a floor cap).** If one card gives 0.9× attackSpeedBoost and another gives 0.9×, the combined multiplier is 0.9 × 0.9 = 0.81. The cap at 0.5 prevents it from going too low.

3. **No duplicate exact cards.** You can equip a Tier 1 Swift Strider and a Tier 2 Swift Strider (they affect the same stat but are different cards), but not two Tier 1 Swift Striders. When `allowDuplicates` is toggled on (debug), this restriction is removed.

4. **Stat caps are absolute limits.** After all modifiers are computed, each final stat is clamped to its cap range. This prevents game-breaking builds.

**How modifiers map to existing params:**

```
CardStat → Target Param Field
─────────────────────────────────
maxRunSpeed → PlayerParams.maxRunSpeed (additive)
jumpSpeed → PlayerParams.jumpSpeed (additive)
dashSpeed → PlayerParams.dashSpeed (additive)
airAcceleration → PlayerParams.airAcceleration (additive)
dashCooldownReduction → PlayerParams.dashCooldownFrames (subtractive — reduces frames)
spearDamage → CombatParams.spearDamage (additive)
snapDamage → CombatParams.snapDamage (additive)
spearReach → CombatParams.spearReach (additive)
snapRadius → CombatParams.snapRadius (additive)
attackSpeedBoost → CombatParams.spearWindupFrames, spearActiveFrames, spearRecoveryFrames,
                    snapWindupFrames, snapActiveFrames, snapRecoveryFrames (multiplicative — floor to 1)
maxHealth → PlayerHealthParams.maxHealth (additive)
invincibilityFrames → PlayerHealthParams.invincibilityFrames (additive)
knockbackResistance → PlayerHealthParams.knockbackSpeed (multiplicative — lower = less knockback)
coyoteFrames → PlayerParams.coyoteFrames (additive)
jumpBufferFrames → PlayerParams.jumpBufferFrames (additive)
wallJumpHorizontalSpeed → PlayerParams.wallJumpHorizontalSpeed (additive)
wallSlideGripSpeed → PlayerParams.wallSlideGripSpeed (additive — negative values mean slower slide)
abilityCooldownReduction → Not directly mapped to a single param — stored as a multiplier
                            that test pages / ability systems can read from the engine
abilityDurationBoost → Same — stored as multiplier, read by ability systems
abilityRangeBoost → Same — stored as multiplier, read by ability systems
```

For the ability-related modifiers (`abilityCooldownReduction`, `abilityDurationBoost`, `abilityRangeBoost`), the `ComputedModifiers` result includes them as multiplicative values. The test page reads these and could apply them to ability params, but for the ink-cards test page specifically, we just display the computed values. Actual ability integration happens when abilities and cards are combined in a real game room (later).

### 4. Crafting System (`src/engine/cards/CraftingSystem.ts`)

The crafting logic for combining cards.

```typescript
export interface CraftingRecipe {
  /** What you need: 2 cards of the same definition and tier */
  inputDefinitionId: CardDefinitionId;
  inputTier: CardTier;
  inputCount: number;  // Always 2 for now
  /** What you get: 1 card of the same definition, next tier */
  outputDefinitionId: CardDefinitionId;
  outputTier: CardTier;
}

export interface CraftingParams {
  /** Number of cards needed for a tier upgrade */
  cardsPerUpgrade: number;
  /** Whether cross-category crafting is allowed (combine different categories) */
  allowCrossCategoryCraft: boolean;
}

export const DEFAULT_CRAFTING_PARAMS: CraftingParams = {
  cardsPerUpgrade: 2,         // Combine 2 Tier 1 → 1 Tier 2, 2 Tier 2 → 1 Tier 3
  allowCrossCategoryCraft: false,
};

export class CraftingSystem {
  params: CraftingParams;

  constructor(params?: Partial<CraftingParams>);

  /**
   * Find all possible crafts from the given collection.
   * A craft is possible when the collection contains 2+ cards of the
   * same definition and tier, and the tier is < 3.
   */
  getAvailableCrafts(collection: InkCard[]): CraftingRecipe[];

  /**
   * Execute a craft: consume input cards, produce output card.
   * Returns the new card, or null if the craft isn't valid.
   * The caller is responsible for adding/removing from the collection.
   */
  craft(collection: InkCard[], recipe: CraftingRecipe): { consumed: InkCard[]; produced: InkCard } | null;

  /**
   * Check if a specific craft is possible with the current collection.
   */
  canCraft(collection: InkCard[], recipe: CraftingRecipe): boolean;
}
```

**Crafting rules:**
- Combine 2 cards of the same type and tier → get 1 card of the same type, next tier
- Tier 1 + Tier 1 → Tier 2
- Tier 2 + Tier 2 → Tier 3
- Tier 3 cards cannot be upgraded further
- Cards used in crafting are consumed (removed from collection)
- Cross-category crafting is disabled by default (a debug toggle enables it for experimentation)

### 5. Card Renderer (`src/engine/cards/CardRenderer.ts`)

Canvas-based card rendering for the crafting UI and deck display.

```typescript
export interface CardRenderOptions {
  x: number;
  y: number;
  width: number;
  height: number;
  selected: boolean;
  equipped: boolean;
  highlighted: boolean;
  dimmed: boolean;
  showTooltip: boolean;
}

export const CARD_RENDER_SIZE = { width: 80, height: 110 };

export class CardRenderer {
  /**
   * Render a single card on the canvas.
   * Cards are rendered as small rectangles with:
   * - Border color = category color
   * - Background = dark with subtle category-tinted gradient
   * - Tier indicator: 1/2/3 dots at top-right
   * - Glyph symbol centered
   * - Name text at bottom
   * - Selected: bright border glow
   * - Equipped: small "E" badge
   */
  static renderCard(
    ctx: CanvasRenderingContext2D,
    card: InkCard,
    options: CardRenderOptions
  ): void;

  /**
   * Render a card tooltip (stat details) next to a card.
   */
  static renderTooltip(
    ctx: CanvasRenderingContext2D,
    card: InkCard,
    x: number,
    y: number,
    maxWidth: number
  ): void;

  /**
   * Render the equipped deck bar (4 slots at top of screen).
   * Shows equipped cards in a horizontal row with empty slot outlines.
   */
  static renderDeckBar(
    ctx: CanvasRenderingContext2D,
    deck: CardDeck,
    x: number,
    y: number,
    selectedSlot: number
  ): void;

  /**
   * Render the card collection grid (scrollable area showing all owned cards).
   */
  static renderCollectionGrid(
    ctx: CanvasRenderingContext2D,
    collection: InkCard[],
    x: number,
    y: number,
    width: number,
    height: number,
    scrollOffset: number,
    selectedIndex: number,
    equippedIds: Set<string>
  ): void;

  /**
   * Render the crafting panel (available recipes, input/output preview).
   */
  static renderCraftingPanel(
    ctx: CanvasRenderingContext2D,
    availableCrafts: CraftingRecipe[],
    collection: InkCard[],
    x: number,
    y: number,
    width: number,
    height: number,
    selectedRecipeIndex: number
  ): void;

  /**
   * Render stat comparison (before/after equipping a card).
   */
  static renderStatComparison(
    ctx: CanvasRenderingContext2D,
    currentModifiers: ComputedModifiers,
    previewModifiers: ComputedModifiers,
    x: number,
    y: number,
    width: number
  ): void;

  /** Get the category color for a card */
  static getCategoryColor(category: CardCategory): string;

  /** Get the tier display string */
  static getTierDots(tier: CardTier): string;
}
```

**Card visual design:**
- Each card is a small rectangle (80×110px at full size) with rounded corners (4px radius)
- Background: very dark (`#1a1a2e`) with a subtle vertical gradient tinted by category color
- Border: 2px solid in category color (teal for swiftness, amber for might, etc.)
- Top-right corner: tier dots (● for each tier level, in white)
- Center: large glyph character (24px font) in category color
- Bottom: card name in small text (10px, white, centered)
- Selected card: border becomes 3px, outer glow effect (box-shadow-like using canvas), category color at 50% alpha
- Equipped indicator: small "E" circle badge at top-left in white
- Dimmed (can't equip): reduced alpha (0.5)

### 6. Test Page (`/test/ink-cards`)

Replace the stub with a full test page that demonstrates the card system with real-time stat modification.

**The test page has TWO modes that the player can switch between:**

1. **Play Mode (default):** Canvas shows a simple movement/combat sandbox level. Equipped cards modify player stats in real time. The deck bar shows at the top of the canvas. Press Tab to switch to Deck Mode.

2. **Deck Mode:** Canvas shows the card collection grid, crafting panel, and equipped deck. The game loop pauses (or runs in background). Navigate cards with arrow keys or mouse clicks. Press Tab to return to Play Mode.

**Test Level Layout (960×540, single screen — no scrolling):**

A small sandbox arena with varied terrain for testing card effects. Includes a target dummy for combat testing.

```typescript
const platforms: Platform[] = [
  // Ground floor
  { x: 0, y: 460, width: 960, height: 80 },
  // Elevated platforms for jump testing
  { x: 100, y: 340, width: 120, height: 20 },
  { x: 360, y: 280, width: 100, height: 20 },
  { x: 600, y: 320, width: 140, height: 20 },
  // Wall for wall mechanics testing
  { x: 250, y: 200, width: 20, height: 260 },
  // High platform (tests enhanced jump)
  { x: 300, y: 180, width: 100, height: 20 },
  // Boundaries
  { x: 0, y: 0, width: 960, height: 20 },       // Ceiling
  { x: 0, y: 0, width: 20, height: 540 },         // Left wall
  { x: 940, y: 0, width: 20, height: 540 },       // Right wall
];
```

**Player spawn:** x=80, y=420

**Target dummy:** Position at x=750, y=420. Use the existing `TargetDummy` from combat system.

**Deck Mode UI Layout (on canvas):**

```
┌═══════════════════════════════════════════════════════════════════┐
│  ┌─EQUIPPED DECK (4 slots)────────────────────────────────────┐  │
│  │  [Card 1]  [Card 2]  [  Empty  ]  [  Empty  ]             │  │
│  └────────────────────────────────────────────────────────────┘  │
│                                                                   │
│  ┌─COLLECTION──────────────────┐  ┌─CRAFTING──────────────────┐  │
│  │  [Card] [Card] [Card] [Card]│  │  Recipe 1: 2× Swift T1   │  │
│  │  [Card] [Card] [Card] [Card]│  │            → Swift T2     │  │
│  │  [Card] [Card] [Card] [Card]│  │                           │  │
│  │  [Card] [Card]              │  │  Recipe 2: 2× Spear T1   │  │
│  │                              │  │            → Spear T2     │  │
│  └──────────────────────────────┘  │                           │  │
│                                     │  [Craft Selected]        │  │
│  ┌─STAT PREVIEW────────────────┐  └───────────────────────────┘  │
│  │  maxRunSpeed: 280 → 300 (+20)│                                │
│  │  jumpSpeed: 380 → 380 (—)    │                                │
│  │  spearDamage: 1 → 2 (+1)     │                                │
│  └───────────────────────────────┘                                │
│                                                                   │
│  [Tab: Return to Play Mode]  [Click card to select]              │
│  [Enter: Equip/Unequip]     [C: Craft selected recipe]          │
└═══════════════════════════════════════════════════════════════════┘
```

**Play Mode HUD (on canvas):**

```
┌═══════════════════════════════════════════════════════════════════┐
│  [Card1] [Card2] [  ] [  ]                           FPS: 60   │
│  Active buffs: +20 RunSpd, +1 SpearDmg                         │
│                                                                   │
│                                                                   │
│                         (game canvas)                             │
│                                                                   │
│                                                                   │
│                                              [Target Dummy: 10HP]│
│                                                                   │
│  [Tab: Open Deck]                                                │
└═══════════════════════════════════════════════════════════════════┘
```

**Starting collection (for testing):**

Give the player a generous starting collection so all features can be tested immediately:

```typescript
const STARTING_COLLECTION: InkCard[] = [
  // 2× of each Tier 1 card (allows crafting to Tier 2)
  // Plus 1× of a few Tier 2 cards for variety
  // Total: ~24 cards

  // Swiftness
  createCard('swift-strider', 1),
  createCard('swift-strider', 1),
  createCard('leap-glyph', 1),
  createCard('leap-glyph', 1),
  createCard('dash-inscription', 1),
  createCard('air-script', 1),

  // Might
  createCard('spear-verse', 1),
  createCard('spear-verse', 1),
  createCard('snap-verse', 1),
  createCard('snap-verse', 1),
  createCard('battle-tempo', 1),
  createCard('battle-tempo', 1),

  // Resilience
  createCard('vellum-shield', 1),
  createCard('vellum-shield', 1),
  createCard('ward-inscription', 1),
  createCard('stoic-page', 1),

  // Precision
  createCard('ledge-reader', 1),
  createCard('ledge-reader', 1),
  createCard('wall-binding', 1),

  // Arcana
  createCard('scribes-haste', 1),
  createCard('ink-well', 1),
  createCard('margin-expander', 1),

  // A couple pre-made Tier 2s
  createCard('swift-strider', 2),
  createCard('vellum-shield', 2),
];
```

**Debug Panel Sections:**

1. **Deck Info** (always visible):
   - Mode: Play / Deck
   - Equipped: X / 4 cards
   - Collection: X cards total
   - Available crafts: X recipes
   - Active stat modifiers: (list of all changes)

2. **Card Engine Params** (expanded):
   | Parameter | Min | Max | Step | Default |
   |-----------|-----|-----|------|---------|
   | Max Equipped | 1 | 8 | 1 | 4 |
   | Allow Duplicates | toggle | | | false |
   | Diminishing Returns | toggle | | | true |
   | Diminishing Factor | 0.3 | 1.0 | 0.05 | 0.7 |

3. **Stat Caps** (collapsed):
   | Parameter | Min | Max | Step | Default |
   |-----------|-----|-----|------|---------|
   | Max Run Speed Cap | 300 | 800 | 25 | 500 |
   | Jump Speed Cap | 400 | 800 | 25 | 600 |
   | Dash Speed Cap | 600 | 1200 | 50 | 900 |
   | Max Health Cap | 5 | 20 | 1 | 10 |

4. **Effective Stats** (expanded, read-only display):
   - Shows base vs. modified value for every stat affected by equipped cards
   - Green text for buffs, red for debuffs, white for unchanged
   - Format: "MaxRunSpeed: 280 → 320 (+40)"

5. **Collection Manager** (collapsed):
   - "Add Random Card" button (adds a random Tier 1 card)
   - "Add All Tier 1s" button (one of each)
   - "Clear Collection" button
   - "Reset to Starting Deck" button

6. **Player State** (collapsed):
   - Standard movement params, state, velocity, position

**Deck Mode Controls:**
| Key | Action |
|-----|--------|
| Tab | Toggle Play/Deck mode |
| Arrow Keys | Navigate cards in collection / recipes |
| Enter | Equip/Unequip selected card |
| C | Craft selected recipe |
| Escape | Deselect / Close tooltip |

**Play Mode Controls:**
| Key | Action |
|-----|--------|
| Tab | Open Deck mode |
| Arrow Left/Right | Move |
| Arrow Up / Z / Space | Jump |
| Arrow Down | Crouch |
| X / Shift | Dash |
| J / Enter | Attack |
| K | Switch weapon |
| D | Toggle debug overlays |

**Pass Criteria (display on page):**

1. Deck mode shows all cards in collection as rendered card objects
2. Cards display correctly: category color border, tier dots, glyph, name
3. Clicking/selecting a card shows its stat modifiers in a tooltip
4. Equipping a card (Enter key) places it in the deck bar
5. Maximum 4 cards can be equipped (extra equip attempts blocked)
6. Unequipping a card (Enter on equipped card) returns it to collection
7. Stat preview shows before/after comparison when hovering a card
8. Crafting panel shows available recipes (2× same card type/tier → next tier)
9. Crafting consumes input cards and produces output card
10. Crafted Tier 2/3 cards have stronger stat bonuses
11. In Play mode, equipped cards modify player stats in real time
12. Movement feels different with Swiftness cards equipped (faster run/jump/dash)
13. Combat damage increases with Might cards equipped (visible on target dummy)
14. Health increases with Resilience cards equipped (heart display changes)
15. Diminishing returns visible when stacking same stat from multiple cards
16. Stat caps prevent values from exceeding limits
17. Toggle to disable diminishing returns shows uncapped stacking
18. All engine params tunable via debug sliders
19. "Effective Stats" panel shows accurate base vs. modified values
20. Collection manager buttons work (add cards, clear, reset)

## Files to Create

- `src/engine/cards/InkCard.ts` — Card data model, types, interfaces
- `src/engine/cards/CardDefinitions.ts` — All 14 card definitions with 3 tiers each (42 card variants)
- `src/engine/cards/CardModifierEngine.ts` — Modifier computation, stacking, caps, application to params
- `src/engine/cards/CraftingSystem.ts` — Crafting recipes, validation, execution
- `src/engine/cards/CardRenderer.ts` — Canvas rendering for cards, deck, collection, crafting UI
- `src/engine/cards/index.ts` — Barrel exports

## Files to Modify

- `src/app/test/ink-cards/page.tsx` — Full test page (replace stub)
- `src/lib/testStatus.ts` — Update ink-cards status to `'in-progress'`

## Important Implementation Notes

1. **Cards do NOT directly mutate PlayerParams/CombatParams/HealthParams.** The `CardModifierEngine` produces new param objects with modifications applied. The test page holds both base params and modified params, and passes the modified params to the player/combat system each frame. Pattern: `const modifiedPlayerParams = engine.applyToPlayerParams(baseParams); playerParamsRef.current = modifiedPlayerParams;`

2. **Modifier application order:** First apply all additive modifiers, then apply all multiplicative modifiers, then clamp to stat caps. This is the standard RPG modifier order (flat bonuses first, percentage scaling second, caps last).

3. **Card IDs must be unique per instance.** Use a simple counter or `crypto.randomUUID()` when creating card instances. Two Tier 1 Swift Striders are different instances with different IDs but the same definition.

4. **The deck mode pauses the game loop.** When in deck mode, call `engine.stop()` or set a flag to skip the physics/render loop. The canvas still renders (drawing the card UI), but player physics don't advance. When returning to play mode, resume the engine.

5. **Actually, don't pause the engine — just swap what renders.** Keep the engine running but swap the render callback. In deck mode, the render callback draws the card UI instead of the game world. The update callback is paused (no physics). This way the engine's timing doesn't get disrupted.

6. **Frame-count-based params (like coyoteFrames, jumpBufferFrames, dashCooldownFrames) must be integers.** When applying modifiers, round frame-count stats to the nearest integer. Use `Math.round()` for additive, `Math.max(1, Math.round(base * multiplier))` for multiplicative to prevent zero-frame values.

7. **attackSpeedBoost is special.** It's a multiplicative modifier that applies to multiple combat frame-count params simultaneously (windup, active, recovery for both weapons). When applying, multiply each frame-count by the attackSpeedBoost multiplier, rounding to integers, with a floor of 1 frame each.

8. **dashCooldownReduction is subtractive.** A positive `dashCooldownReduction` value (e.g., 2) subtracts from `dashCooldownFrames`. Clamp to a minimum of 4 frames to prevent zero-cooldown dash spam.

9. **The target dummy in Play mode.** Import and use `TargetDummy` from the combat system. Place it at x=750. Wire combat the same way as the combat-melee test page: `combatSystem.update(...)` → `combatSystem.checkHits([targetDummy])` → apply damage. The dummy's health and damage numbers let the player see that Might cards actually increase damage.

10. **Card rendering is canvas-based, NOT React.** The deck mode UI renders directly on the canvas context. This keeps it consistent with the rest of the engine and avoids mixing React DOM elements with the game canvas for the card interface. The debug panel sidebar is still React (sliders, buttons).

11. **Mouse interaction for deck mode.** Add mouse click handling in the test page for selecting cards in the collection grid. Use `canvas.addEventListener('click', ...)` and compute which card was clicked based on the grid layout. Keyboard navigation (arrow keys) works alongside mouse.

12. **Collection grid layout.** Cards are arranged in a grid: 4 columns × N rows. Each card slot is 90×120px (80×110 card + 10px padding). The grid scrolls vertically if the collection is large. Track `scrollOffset` and clamp to valid range.

13. **Crafting execution flow:** User selects a recipe in the crafting panel → presses C → `craftingSystem.craft()` consumes 2 cards from collection, produces 1 new card → new card is added to collection → crafting panel refreshes available recipes.

14. **Category color consistency.** Use the EXACT same category colors throughout: card borders, glyph color, stat text in the preview, deck bar slot highlights. This creates a clear visual language: "teal = speed, amber = damage, green = defense, purple = technique, indigo = abilities."

15. **Initial equip.** The starting deck has no cards equipped — all 24 cards are in the collection. The player must manually equip cards to see their effects. This teaches the system.

## Design Decisions (Pre-settled)

1. **4 equipped slots.** Small enough to force meaningful choices, large enough to allow build variety. A player can't just equip one of everything — they must specialize or diversify carefully.

2. **Diminishing returns at 0.7.** The second card contributing to the same stat gives 70% effect. This discourages pure stacking and encourages diverse builds. Two +20 speed cards give +34 total (not +40), making a +20 speed + +1 damage split more interesting.

3. **Simple 2:1 crafting ratio.** Two of the same tier → one of the next tier. Easy to understand, creates a clear progression path (collect → combine → equip stronger versions).

4. **No cross-category crafting.** Keeps the crafting system simple and predictable. You upgrade within a category, not across categories. This could be expanded later for more complex recipes.

5. **5 categories map to 5 play styles.** Swiftness for speedrunners, Might for combat focus, Resilience for cautious players, Precision for platforming specialists, Arcana for ability-focused builds.

6. **Cards are purely beneficial.** No negative stats, no trade-offs within a single card. The trade-off is the limited slot count — equipping a Might card means NOT equipping a Swiftness card.

7. **Stat caps exist to preserve game feel.** The movement system was carefully tuned. Letting players push maxRunSpeed to 800 would break level design. Caps ensure cards enhance but don't invalidate the core tuning. The caps are generous enough that builds feel meaningfully different.

8. **Canvas-based card UI, not React.** The card interface is part of the game experience, not a web form. Rendering it on the canvas keeps visual consistency and avoids DOM/canvas mixing issues. The debug panel sidebar remains React.

9. **14 card definitions × 3 tiers = 42 card variants.** This is a solid content baseline. Each category has 3-4 unique card types, and each has 3 tiers. Enough variety for interesting builds without being overwhelming.

10. **Starting collection is generous for testing.** The player starts with 24 cards including duplicates for crafting. This lets testers immediately explore all features without grinding. In the real game, cards would be earned through exploration and combat.

## Verification

- [ ] `npx tsc --noEmit` passes with zero errors
- [ ] `npm run build` succeeds
- [ ] Navigate to `/test/ink-cards` — canvas renders with play mode (sandbox level + target dummy)
- [ ] Tab key toggles between Play mode and Deck mode
- [ ] Deck mode renders: equipped deck bar (4 slots), collection grid, crafting panel, stat preview
- [ ] Cards render with correct visual design: category-colored border, tier dots, glyph, name
- [ ] Can select a card in collection with arrow keys or mouse click
- [ ] Selected card shows tooltip with stat modifier details
- [ ] Enter key equips/unequips selected card
- [ ] Equipped deck bar updates when cards are equipped/unequipped
- [ ] Maximum 4 cards enforced (5th equip attempt blocked)
- [ ] Stat preview shows base → modified values for all affected stats
- [ ] Crafting panel shows available recipes when 2+ same cards exist
- [ ] Pressing C on a selected recipe consumes cards and produces upgraded card
- [ ] Tier 2/3 cards show in collection after crafting
- [ ] In Play mode: Swiftness cards visibly increase run/jump/dash speed
- [ ] In Play mode: Might cards visibly increase damage on target dummy
- [ ] In Play mode: Resilience cards increase visible health hearts
- [ ] Diminishing returns: stacking 2 speed cards gives less than 2× the bonus
- [ ] Stat caps: even with max speed cards, runSpeed doesn't exceed 500
- [ ] Debug toggle: disabling diminishing returns shows full stacking
- [ ] "Effective Stats" debug panel shows accurate before/after values
- [ ] Collection manager buttons work (Add Random, Add All T1s, Clear, Reset)
- [ ] All CardModifierEngine params tunable via sliders
- [ ] FPS stays at ~60fps in both modes
- [ ] Existing movement and combat work perfectly — no regressions

---

## Completion Summary

### Files Created
- `src/engine/cards/InkCard.ts` — Card data model: CardCategory, CardTier, CardStat (20 stats), StatModifier, InkCard, CardDeck interfaces. Category colors, display names as constants.
- `src/engine/cards/CardDefinitions.ts` — 15 card definitions (4 swiftness, 3 might, 3 resilience, 2 precision, 3 arcana) × 3 tiers = 45 card variants. `createCard()` factory, `getAllCardDefinitions()`, `getCardDefinitionsByCategory()`.
- `src/engine/cards/CardModifierEngine.ts` — Core stat modification engine. Equip/unequip, collection management, `computeModifiers()` with diminishing returns (0.7× factor) and stat caps. `applyToPlayerParams()`, `applyToCombatParams()`, `applyToHealthParams()` produce new param objects. `getModifierSummary()` for UI display.
- `src/engine/cards/CraftingSystem.ts` — 2-to-1 tier upgrade crafting. `getAvailableCrafts()`, `canCraft()`, `craft()`. Configurable cardsPerUpgrade.
- `src/engine/cards/CardRenderer.ts` — Canvas-based rendering: individual cards (80×110px, category-colored border, tier dots, glyph, name), deck bar (4 equipped slots), collection grid (4-column scrollable), crafting panel with recipe list, stat comparison display, tooltips.
- `src/engine/cards/index.ts` — Barrel exports for all card system types and classes.

### Files Modified
- `src/app/test/ink-cards/page.tsx` — Full test page replacing stub. Two modes: Play mode (sandbox arena with target dummy, cards modify player/combat/health params in real time, mini deck bar HUD, active buffs summary) and Deck mode (collection grid with selection/scrolling, equipped deck bar, crafting panel, stat preview, tooltips). Mouse + keyboard navigation. Tab toggles modes. Enter equips/unequips. C crafts. Debug panel with Deck Info, Active Modifiers, Card Engine Params (sliders + toggles), Stat Caps, Collection Manager buttons.
- `src/lib/testStatus.ts` — Updated Ink Cards status to `'in-progress'`
- `AGENTS.md` — Added Ink Cards system documentation, updated Phase 4 progress table

### Verification
- `npx tsc --noEmit` — passes with zero errors
- `npm run build` — succeeds, all routes including `/test/ink-cards` build correctly

---

## Review Notes (Reviewer: d97a3a1a)

### Issues Found and Fixed

**1. Tab key double-handling bug (FIXED)**
- **File:** `src/app/test/ink-cards/page.tsx`
- **Severity:** High — Tab toggle was completely broken in deck mode
- **Problem:** Both `handleDeckKeys` and `handlePlayKeys` handled the Tab key. Since both were registered as `window.addEventListener("keydown", ...)`, pressing Tab in deck mode would: (1) `handleDeckKeys` would set mode to "play", then (2) `handlePlayKeys` would see `modeRef.current === "play"` and immediately toggle it back to "deck". Net result: Tab did nothing when in deck mode.
- **Fix:** Removed the Tab case from `handleDeckKeys`. The `handlePlayKeys` handler already handles Tab toggling for both directions, so the deck handler's Tab case was redundant and caused the race condition.

**2. Empty for loop in `resetCollection` (FIXED)**
- **File:** `src/app/test/ink-cards/page.tsx`
- **Severity:** Low — dead code
- **Problem:** `for (const card of ce.deck.collection) { // collection is already set }` — an empty loop iterating over the collection doing nothing.
- **Fix:** Removed the empty loop.

### Items Reviewed, No Issues

- **InkCard.ts** — Clean types, all 20 CardStats accounted for, category colors/names match spec
- **CardDefinitions.ts** — 15 definitions (not 14 as spec says — 4 swiftness, 3 might, 3 resilience, 2 precision, 3 arcana = 15), × 3 tiers = 45 variants. `createCard()` uses counter + timestamp for unique IDs. Modifier values match spec.
- **CardModifierEngine.ts** — Correctly implements diminishing returns for additive stats, multiplicative stat multiplication, stat caps. `applyToPlayerParams`/`applyToCombatParams`/`applyToHealthParams` correctly map CardStats to actual param fields. Frame-count stats are properly rounded. `dashCooldownReduction` is properly subtractive with a floor of 4. `attackSpeedBoost` correctly multiplies all 6 combat frame-count params with a floor of 1.
- **CraftingSystem.ts** — Clean 2-to-1 crafting logic. Groups by definitionId+tier, respects tier 3 cap. `craft()` correctly finds and returns consumed cards.
- **CardRenderer.ts** — Canvas rendering is correct: roundRect helper, hexToRgba, truncateText. Proper save/restore for canvas state. Collection grid uses clip region. Scroll indicator math is correct.
- **index.ts** — Barrel exports all types and values correctly.
- **testStatus.ts** — Ink Cards correctly set to 'in-progress'.
- **No memory leaks** — Event listeners (keydown, click) are properly cleaned up in the unmount handler.
- **No frame-rate dependent issues** — Card system is purely stat computation, no frame-dependent logic.
- **TypeScript** — No `any` types used (except the necessary `unknown` casts for engine cleanup pattern). All card types are properly typed.
